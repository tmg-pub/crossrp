-------------------------------------------------------------------------------
-- Cross RP by Tammya-MoonGuard (2019)
--
-- The "Alliance" Protocol. Turns suitable players into routers to cross the
--  faction and realm divide.
--
-- It's not really my fancy to make things so optimized like this (using a lot
--  of local references), but since this is a sort of background service that's
--  always running, I wanted there to be a bit of a speed priority.
-- Same with comm.lua, the lower level communications that everything relies
--  on.
-------------------------------------------------------------------------------
local _, Me        = ...
local LibRealmInfo = LibStub( "LibRealmInfo" )
local Comm         = Me.Comm
-------------------------------------------------------------------------------
-- Imports. We don't really want to clutter up our code with a bunch of
--                               boilerplate, so leave out rarely used globals.
local min,      max,      ipairs, pairs, tonumber, tostring, UnitGUID =
      math.min, math.max, ipairs, pairs, tonumber, tostring, UnitGUID
local strbyte,     strmatch,     strsub,     strlower,     strupper =
      string.byte, string.match, string.sub, string.lower, string.upper
local gsub,        UnitIsPlayer, UnitFactionGroup, UnitGUID, type =
      string.gsub, UnitIsPlayer, UnitFactionGroup, UnitGUID, type
local DebugLog,    DebugLog2,    tblconcat,    next, C_BattleNet =
      Me.DebugLog, Me.DebugLog2, table.concat, next, C_BattleNet
-------------------------------------------------------------------------------
-- Some terminology:
--   FULLNAME: A player name and realm in the normal game format,
--              e.g. Tammya-MoonGuard.
--   BAND: A set of people that have the same faction and realm.
--   DEST/DESTINATION: A player name and a band.
--   LINK: A link between two Battle.net friends. Both sides of a link must
--           have Cross RP and be "hosting" for a link to be formed.
--   BRIDGE: A player local to you (on the same realm and faction) that has one
--            or more links to other realms or factions. The player themselves
--            are also a valid bridge if they have links and are hosting.
-- Bands are formatted as <number><A/H>, meaning the realm ID and Alliance
--  or Horde. e.g. "1H" is Moon Guard Horde. Some realms are selected as
--  "primo", which means they have a single digit realm ID.
-- Destinations are formatted as <player><band>, <player> being their toon name
--  without their realm attached (as that's part of the band). e.g. "Tammya1A"
--  for Tammya-MoonGuard Alliance.
-- For connected realms, there may be multiple bands that are linked, and the
--  one with the lowest realm ID will be used as the "base band", which is
--  basically for routing purposes. The links and bridge structs are indexed
--  by "base" bands where applicable.
-------------------------------------------------------------------------------
-- Our module object to export variables too. Rule of thumb is to export as
--  much as possible (especially tables, as those can share references with
--  locals).
local Proto = {}                                               Me.Proto = Proto
-------------------------------------------------------------------------------
-- When the user touches someone (mouseover), the band that someone belongs
--  to is set to 'active'. This table contains band names mapped to time
--  the user touched them, and the band is active for BAND_TOUCH_ACTIVE
--  seconds.
local m_active_bands = {}                   Proto.active_bands = m_active_bands
-------------------------------------------------------------------------------
-- Hosting is when we are offering a connection to the opposite faction or
--  other realms through our Bnet friends. This may be true anyway even if we
--  have no links, which just means that we are open to hosting but aren't
--  really able to at that moment. `hosting_time` is just a number updated
--  with the time so long as we are hosting (and it pauses when we stop
--  hosting).
local m_hosting = false
local m_hosting_time = 0
-------------------------------------------------------------------------------
-- We have some procedures in place to make sure that data is transferred
--  'securely'. This is used for connecting raid groups, where we use a
--  a different addon channel (that only people in the linked groups know), and
--  for Bnet transfers (which ignore the addon-channel filter) use a sort of
--  authentication method.
-------------------------------------------------------------------------------
-- This is the password the linked groups are using:
local m_secure_code = nil
-------------------------------------------------------------------------------
-- `channel` is the addon prefix that we use, generated by taking the hash
--  of the secure code against a constant. Currently, it's base32 and suitable
--  for a suffix for an ingame channel (which earlier designs called for).
local m_secure_channel = nil
-------------------------------------------------------------------------------
-- `secure_hash` is the sha256 hash of our secure code. When broadcasting
--  status and such, we send a piece of this as a method of authentication.
-- Basically, this is just a way to let people know what password we're using,
--  without actually sharing the password.
local m_secure_hash = nil
-------------------------------------------------------------------------------
-- `secure_myhash` is the sha256 hash of our secure code mixed with our
--  fullname. This is a way to let people know that we actually have the
--  password, and we aren't just copying the hash from someone else - because
--  it's salted with our fullname, a constant unique to us.
local m_secure_myhash = nil
-------------------------------------------------------------------------------
-- This table is to keep track of what "secure codes" we receive from a player.
-- It's indexed by both fullnames and gameids, as we can receive that sort of
--  data over the broadcasted status (ST), and the Battle.net status (HI).
-- [<fullname> or <bnet account id> or game id] = {
--   code: The secure code that we used to compute their state. This is not
--          what code they're using. It's our code we used when checking if
--          they're secure.
--   h1: The public hash of the user's secure code.
--   h2: The personal public hash of the user's secure code
--        (secure code + their name)
--   secure: True if we can contact this user over our secure channel, or if
--            they're safe to be contacted with secure data over Bnet (which
--            doesn't have addon prefix filtering).
-- }
local m_node_secure_data = {}       Proto.node_secure_data = m_node_secure_data
-------------------------------------------------------------------------------
-- The time we last broadcast our status to the local channel. We do it around
--  every two minutes, or STATUS_BROADCAST_INTERVAL seconds. If someone doesn't
--  broadcast their status for a while, their bridge is considered invalidated
--                                           and we will remove it next update.
local m_status_broadcast_time = 0
-------------------------------------------------------------------------------
-- This is a flag to make our next status broadcast use a higher priority, so
--  that during heavy-load situations, the status message is prioritized.
-- This is set when we lose a link to someone - we broadcast that state as soon
--  as possible, to deter people from trying to use a route that is no longer
--  valid.
local m_status_broadcast_fast = false
-------------------------------------------------------------------------------
-- True if the last status we broadcast had an empty band list. Basically stops
--  us from rebroadcasting that, as we don't need to periodically tell people
--                                                 that we can't host for them.
local m_status_last_sent_empty = false
-------------------------------------------------------------------------------
-- These are just cached values of our destination and band. Should look
--  something like "Tammya1A", and "1A".
local m_my_dest = nil
local m_my_band = nil
-------------------------------------------------------------------------------
-- Indexed by bands, this is a list of NodeSets that contain our links to other
--  realms and factions (the user's Battle.net friends that are using
--  Cross RP). Typically these sets and lists will be very small, as the user
--  probably won't have that many friends across the faction wall (unless they
--  play Moon Guard Horde), but we use the same storage as bridges (which
--  should be a lot more in number) for elegance and convenience.
-- Basically what I mean is that NodeSets are optimized to work with a lot of
--                             users, and it's kind of overkill for small sets.
local m_links = {}                                        Proto.links = m_links
-------------------------------------------------------------------------------
-- Indexed by bands, this is our list of NodeSets that contain bridges.
-- The NodeSet class handles managing what bridge to use. We may also have
--  ourself in the nodeset for our local band, as we can be a valid bridge for
--  ourself.
local m_bridges = {}                                  Proto.bridges = m_bridges
-------------------------------------------------------------------------------
-- This is a list of links that are actively hosting for us, redundant data
--  that complements the m_links sets so we can scan them quickly and weed out
--  things like offline users.
local m_link_ids = {}                               Proto.link_ids = m_link_ids
-------------------------------------------------------------------------------
-- This is a list similar to the one above, game account IDs mapped to a state.
--  This tracks all users who have Cross RP installed. It's a tristate.
--    `nil`   = The user is unknown (unknown or has gone offline).
--    `false` = The user was seen online, and we sent a probe to them.
--    `true`  = This is a Cross RP user.
local m_crossrp_gameids = {}          Proto.crossrp_gameids = m_crossrp_gameids
-------------------------------------------------------------------------------
-- Just a list of what we haved called C_ChatInfo.RegisterAddonMessagePrefix
--  with, so we don't make duplicate calls.
local m_registered_addon_prefixes = {}        Proto.registered_addon_prefixes =
                                                    m_registered_addon_prefixes
-------------------------------------------------------------------------------
-- A list of realms that are connected to us, formatted as the realm name
--  without spaces or dashes (e.g. "MoonGuard"). Example use is when we
--  broadcast our status to our friends list - we don't want to send it to
--  anyone that is linked to our band.
local m_linked_realms = {}                Proto.linked_realms = m_linked_realms
-------------------------------------------------------------------------------
-- This is for the network status display. Basically, just shortens realm names
--  for common RP realms. Make it pretty for them. Other realms will show up
--  as a truncated string.
local m_realm_names = {
	ArgentDawn     = "AD";
	EmeraldDream   = "ED";
	MoonGuard      = "MG";
	WyrmrestAccord = "WRA";
}                                           Proto.m_realm_names = m_realm_names
-------------------------------------------------------------------------------
-- Indexed by "command" which is the first word found in a received message,
--  this is a callback list for when we receive a routed message. Registered
--  with `Proto.SetMessageHandler( command, handler )`.
local m_message_handlers = {}       Proto.message_handlers = m_message_handlers
-------------------------------------------------------------------------------
-- Our list of handlers we want to register with the Comm module. BROADCAST is
--  for (addon) messages received in the broadcast channel. BNET is for
--  whispered GameData messages over Battle.net, and WHISPER is local addon
--  whisper messages. Basically, our protocol is broken up into different
--  transfer mediums like that. I /could/ have designed the system so that
--  all commands share a single list, but I think there's a little bit of
--  network security to be had by forcing the proper/expected channels for
--  different message types, like the routing commands begin with R1 over
--  WHISPER, then R2 over BNET, and then R3 over BROADCAST or WHISPER.
Proto.handlers = {
	BROADCAST = {};
	BNET      = {};
	WHISPER   = {};
}
-------------------------------------------------------------------------------
-- Simple statistic of GetTime() when we started, for uptime or whatever.
Proto.start_time = nil
-------------------------------------------------------------------------------
-- UMIDs are Unique Message IDs. Basically a way to prevent a receiving side
--  from reading the same message twice. Each message we route has an ID
--  attached. This prefix is a randomly generated code, to help ensure that
--  when the user /reloads or relogs, they will generate a new unique ID when
--  sending another message. A bit overkill, but I hate depending on luck, even
--  if the chance to fail is super, super slim.
local m_umid_prefix = ""
-------------------------------------------------------------------------------
-- The prefix is mixed with this incrementing number to create a new UMID.
local m_next_umid_serial = 1
-------------------------------------------------------------------------------
-- A list of UMIDs that we have seen already, so if we get another message with
--  a UMID in this list, we ignore it. The values are time, and they expire
--  after five minutes (which /should/ be plenty of time to transfer anything).
local m_seen_umids = {}                         Proto.seen_umids = m_seen_umids
-------------------------------------------------------------------------------
-- A `sender` is an active task to send data from our end. They hold what data
--  we're sending, what UMIDs are used, what destinations to send it to, and
--  then we do some management on top of them to make sure they get sent.
--  Especially important for "guaranteed" messages, where the sender stays
--  active until an ACK is received (used mainly for RP chat).
local m_senders = {}                                  Proto.senders = m_senders
-------------------------------------------------------------------------------
-- Version statistics. `version_counts[version_string]` is the number of users
--  using that version. `user_versions` holds the version strings for each
--  user, which can be a gameid or a fullname.
local m_version_counts = {}             Proto.version_counts = m_version_counts
local m_user_versions = {}                Proto.user_versions = m_user_versions
-------------------------------------------------------------------------------
-- This is what step of our initialization process is done.
--    0 = Joining game channel.
--    1 = Waiting for Bnet (link) status messages.
--    2 = Waiting for local (bridge) status messages.
--    3 = Fully initialized.
Proto.init_state = -1
-------------------------------------------------------------------------------
-- These servers get a special single digit realm identifier because they're
--  very popular. This may change if we decide to support non RP servers
--                                     (these IDs are overwriting PvE servers).
local PRIMO_RP_SERVERS = {
	[1] = 1365; -- Moon Guard US
	[2] = 536;  -- Argent Dawn EU
	[3] = 1369; -- Wyrmrest Accord US
}
local PRIMO_RP_SERVERS_R = {}
for k, v in pairs( PRIMO_RP_SERVERS ) do
	PRIMO_RP_SERVERS_R[v] = k
end

-------------------------------------------------------------------------------
-- TIMING
-------------------------------------------------------------------------------
-- The time we wait before starting up the system, to give the game and other
--  addons a bit of time to get settled in. After this expires, we try to join
--                     the game channel and then start our post initialization.
local START_DELAY = 1.0
-------------------------------------------------------------------------------
-- When we stop hosting, we still will accept messages as a bridge/router for
--  this many seconds. This is so that if we stop hosting, and other clients
--  haven't registered that yet, we're not going to throw away their messages.
-- After the time is up, then any new (routing) messages will be ignored.
local HOSTING_GRACE_PERIOD = 60 * 5
-------------------------------------------------------------------------------
-- When touching a player of a foreign band, that band will become "active" for
--  this many seconds. I don't believe this is being used right now, but it
--                                 should trigger an event for future purposes.
local BAND_TOUCH_ACTIVE = 60 * 15
-------------------------------------------------------------------------------
-- The period that we broadcast our status; this includes both the channel
--     broadcast, and the whisper broadcast to Bnet friends. Every two minutes.
local STATUS_BROADCAST_INTERVAL = 120
-------------------------------------------------------------------------------
-- The time we wait for an ACK after sending a guaranteed message. PER_BYTE
--  is added per byte in the message, a sort of estimation of how many extra
--                  seconds we should add for additional chunks in the message.
local ACK_TIMEOUT = 10.0
local ACK_TIMEOUT_PER_BYTE = 2.0/250
-------------------------------------------------------------------------------
-- The time we will leave a sender alive before we assume that the message was
--  sent. Basically, this is how many seconds we wait for the "this player is
--  offline" from the system before closing the sender. If we do get that
--                      notification within this period, we resend the message.
local ONLINE_TIMEOUT = 3.0

-------------------------------------------------------------------------------
-- DESTINATION UTILITY FUNCTIONS
-------------------------------------------------------------------------------
-- Returns the band for a valid game unit. A "band" is a short identifier for
--                                                        realm ID and faction.
local function GetBandFromUnit( unit )
	if not UnitIsPlayer( unit ) then return end
	local guid = UnitGUID( unit )
	if not guid then return end

	-- 2.0.1 - Make sure that we have realm info for this GUID. Could be wonky
	--                              when the player is logging in or something.
	local _, _, _, _, _, _, realm = GetPlayerInfoByGUID(guid)
	if not realm then return end
	if realm == "" then realm = Me.realm end

	local realm = LibRealmInfo:GetRealmInfo( realm )
	local faction = UnitFactionGroup( unit )
	-- 2.0.4 apparently this can return nil in some situations.
	if not faction then return end
	if realm <= #PRIMO_RP_SERVERS then
		realm = "0" .. realm
	else
		realm = PRIMO_RP_SERVERS_R[realm] or realm
	end
	return realm .. strsub( faction, 1, 1 )
end                                     Proto.GetBandFromUnit = GetBandFromUnit

-------------------------------------------------------------------------------
-- Parses the band part of a destination. "Destination" values are player names
--                                     and bands put together, e.g. "Tammya1A".
local function GetBandFromDest( destination )
	return strmatch( destination, "%d+[AH]" )
end                                     Proto.GetBandFromDest = GetBandFromDest

-------------------------------------------------------------------------------
-- A "fullname" is a player name with realm. Destinations contain that and
--  faction, and this packs them together. Destinations have the player name
--  realm ID, and faction ID.
-- Returns a destination for fullname and faction given.
local function DestFromFullname( fullname, faction )
	local realm = LibRealmInfo:GetRealmInfo( strmatch( fullname, "%-(.+)" ) or Me.realm )
	if realm <= #PRIMO_RP_SERVERS then
		realm = "0" .. realm
	else
		realm = PRIMO_RP_SERVERS_R[realm] or realm
	end
	return strmatch( fullname, "^[^-]*" ) .. realm .. faction
end                                   Proto.DestFromFullname = DestFromFullname

-------------------------------------------------------------------------------
-- Returns a fullname from the destination given.
-- e.g. Tammya1A -> Tammya-MoonGuard.
-- Faction bit is discarded.
local function DestToFullname( dest )
	local name, realm = strmatch( dest, "([^%d%s]+)(%d+)" )

	-- The destination doesn't necessarily have to be properly capitalized, but
	--  a lot of other things depend on particular capitalization.
	-- Format so first (UTF-8) character is capitalized only.
	name = strlower( name )
	name = gsub( name, "^[%z\1-\127\194-\244][\128-\191]*", strupper )

	-- If the first character in a string is "0" then it bypasses the "primo"
	--  server list. In other words, if we want to use realm ID 2 directly
	--  without getting remapped by our primo list, we have to format it as
	--  "02".
	local primo = strbyte( realm, 1 ) ~= 48
	realm = tonumber( realm )
	realm = primo and PRIMO_RP_SERVERS[realm] or realm
	local _, _, realm_apiname = LibRealmInfo:GetRealmInfoByID( realm )
	return name .. "-" .. realm_apiname
end                                       Proto.DestToFullname = DestToFullname

-------------------------------------------------------------------------------
-- Parses a destination and returns the "base" band for it. For realms that are
--  connected to other realms, this scans the connected list and returns the
--  band with the lowest realm ID. For example, if these three bands are
--  part of the same connected realm group, "23A" "333A" and "1235A", then it
--  returns "23A" for any of those destinations. Used mainly for indexing our
--             bridge and link list (which are meant to point to unique bands).
local function GetLinkedBand( dest1 )
	local realm, faction = strmatch( dest1, "(%d+)([AH])" )
	local primo = strbyte( realm, 1 ) ~= 48
	realm = tonumber( realm )
	if primo and PRIMO_RP_SERVERS[realm] then
		-- primo servers aren't linked.
		return realm .. faction
	end
	local realmid, _,_,_,_,_,_,_,
	                       connections = LibRealmInfo:GetRealmInfoByID( realm )
	for _, v in pairs( connections ) do
		realm = min( realm, v )
	end
	return realm .. faction
end                                         Proto.GetLinkedBand = GetLinkedBand

-------------------------------------------------------------------------------
-- Returns true if these two destinations are part of the same band, or if
--  they're on linked bands.
local function IsDestLinked( dest1, dest2 )
	dest1 = dest1 or ''
	dest2 = dest2 or ''
	if strbyte( dest1, #dest1 ) ~= strbyte( dest2, #dest2 ) then
		-- Faction mismatch is always false. The two might be on the same
		--  connected realm group, but they have to be on the same faction to
		--  contact each other.
		return false
	end
	local band1, band2 = strmatch( dest1, "(%d+)[AH]" ),
	                     strmatch( dest2, "(%d+)[AH]" )
	if not band1 or not band2 then return end
	if band1 == band2 then
		-- A nice shortcut.
		return true
	end

	if GetLinkedBand(dest1) == GetLinkedBand(dest2) then
		return true
	end
end                                           Proto.IsDestLinked = IsDestLinked

-------------------------------------------------------------------------------
-- Returns true if the destination given is on our band, or if we're connected
--  to that band. In other words, if the dest is "local" then we can send them
--  a normal addon whisper.
local function IsDestLocal( dest )
	return IsDestLinked( m_my_dest, dest )
end                                             Proto.IsDestLocal = IsDestLocal

-------------------------------------------------------------------------------
-- Returns a band name in a readable format. Not /too/ readable, but meant for
--                                   the network monitor. e.g. "MG-H" for "1H".
-- `full` now makes it return a completely readable name,
--   e.g. "Moon Guard Horde".
local function GetBandName( band, full )
	local realm, faction = strmatch( band, "(%d+)([AH])" )
	if not realm then return UNKNOWN end
	local primo = strbyte( realm, 1 ) ~= 48
	realm = tonumber( realm )
	realm = primo and PRIMO_RP_SERVERS[realm] or realm
	local realmid,realmname,apiname = LibRealmInfo:GetRealmInfoByID( realm )
	if full then
		return realmname .. " " ..
		                 (faction == "A" and FACTION_ALLIANCE or FACTION_HORDE)
	end
	-- Look for a fancy name we have for the realm, or just use the first 5
	--  characters.
	apiname = m_realm_names[apiname] or strsub( apiname, 1, 5 )
	return strupper(apiname .. "-" .. faction)
end                                             Proto.GetBandName = GetBandName


-------------------------------------------------------------------------------
-- MISC UTILITY
-------------------------------------------------------------------------------
-- This function returns information abouto our bridges, what bands we can
--  access. Used for the minimap tooltip display.
-- Returns list of {
--   band    Band index this entry is for.
--   quota   Quots this band has. May be 0, meaning the band has become
--             unavailable.
--   secure  If we can access this band using our secure channel.
--   direct  If we own a link to this band.
--   active  If we have seen any users on this band recently (by mouseover).
-- }
-- This is meant to be diagnostic data only, and shouldn't be considered a
--  super accurate API (updated only once per second, and may briefly contain
--                                                      outdated information).
local m_network_status = {}
local m_last_network_status_time = 0
local function GetNetworkStatus()
	-- This function is kind of heavy, and it doesn't need to be cutting edge
	--  data, so we cache it every second.
	local time = GetTime()
	if time < m_last_network_status_time + 1.0 then
		return m_network_status
	end
	m_last_network_status_time = time
	wipe( m_network_status )

	for band, set in pairs( m_bridges ) do
		-- Quota internally is calculated as 1000/load, but in here we convert
		--  it to 10/load, so a healthy user will have 10 points, double load
		--  will be 5 points, etc.
		local qsum = math.ceil(set.quota_sums.all * 10 / 1000)
		local secure = set.node_counts.secure > 0
		local includes_self = set.nodes[Me.fullname]
		local active = GetTime() < (m_active_bands[band] or 0) + BAND_TOUCH_ACTIVE

		-- Ignore any entries that are dead links and inactive bands.
		if (qsum > 0 or active) or Me.DEBUG_MODE then
			table.insert( m_network_status, {
				band   = band;
				quota  = qsum;
				nodes  = set.node_counts.all;
				secure = secure;
				direct = includes_self;
				active = active;
				name   = GetBandName( band, true );
			})
		end
	end

	--[[ some testing code here for the sorting function.
	m_network_status = {
		{ band = "1H", quota = 10, nodes = 1, secure = false, direct = false, active = false };
		{ band = "3A", quota = 0, nodes = 0, secure = false, direct = false, active = false };
		{ band = "3H", quota = 1, nodes = 1, secure = false, direct = false, active = false };
		{ band = "66A", quota = 10, nodes = 1, secure = false, direct = true, active = false };
		{ band = "70H", quota = 0, nodes = 0, secure = false, direct = false, active = false };
		{ band = "2A", quota = 3, nodes = 3, secure = false, direct = false, active = false };
		{ band = "2H", quota = 0, nodes = 0, secure = false, direct = false, active = false }
	}
	for k,v in pairs( m_network_status ) do
		v.name = GetBandName( v.band )
		print( v.name )
	end]]

	local my_realm = m_my_band:match( "(%d+)[AH]" )

	-- Sort alphabetically by bands.
	table.sort( m_network_status, function( a, b )
		local a_online, b_online = a.quota > 0, b.quota > 0
		if a_online ~= b_online then
			return a_online
		else
			local a_active, b_active = a.active, b.active
			if a_active ~= b_active then
				return a_active
			else
				local a_home = a.band:match( "(%d+)[AH]" ) == my_realm
				local b_home = b.band:match( "(%d+)[AH]" ) == my_realm
				if a_home ~= b_home then
					return a_home
				else
					return a.name < b.name
				end
			end
		end
	end)

	return m_network_status
end                                   Proto.GetNetworkStatus = GetNetworkStatus

-------------------------------------------------------------------------------
-- Records a version number from a user. User can be a gameid or a fullname.
--  Version data can be printed with debug functions, and the latest version
--                                     number can also be shown from this data.
local function SaveVersion( version, user )
	if not m_user_versions[user] then
		-- New user, record their version.
		m_user_versions[user] = version
		m_version_counts[version] = (m_version_counts[version] or 0) + 1
	else
		-- Ignore updates.
	end
end

-------------------------------------------------------------------------------
-- Returns true if the user (as reported by the client) is experiencing high
--                                      latency, and they shouldn't be hosting.
local function HasUnsuitableLag()
	local _,_, home_lag, world_lag = GetNetStats()
	return max( home_lag, world_lag ) > 500
end                                   Proto.HasUnsuitableLag = HasUnsuitableLag

-------------------------------------------------------------------------------
-- Returns an iterator for a player's game accounts. Usually a WoW player is
--  only logged into one game account, but some people can have two, or even
--  three. The quicker/more efficient methods can only read from the first
--  game account, and aren't very useful for our case, where any of those game
--  accounts can receive Bnet data and act as links.
-- Iterator returns `fullname`, `faction` (single char), `gameid`
local BNET_CLIENT_WOW            = BNET_CLIENT_WOW  -- (Inner function
local BNGetFriendIndex           = BNGetFriendIndex --          optimizations.)
local function GameAccounts( bnet_account_id )
	local account = 1
	local friend_index = BNGetFriendIndex( bnet_account_id )
	local num_accounts = C_BattleNet.GetFriendNumGameAccounts( friend_index )
	return function()
		while account <= num_accounts do
			local game_info = C_BattleNet.GetFriendGameAccountInfo( friend_index, account )
			account = account + 1

			local cname, realm = game_info.characterName, game_info.realmName
			if game_info.clientProgram == BNET_CLIENT_WOW
			                 and game_info.wowProjectID == 1
			                 and cname and cname ~= ""
					         and realm and realm ~= "" then
				realm = realm:gsub( "[ -]", "" )
				return cname .. "-" .. realm,
				       strsub( game_info.factionName, 1, 1 ),
				       game_info.gameAccountID
			end
		end
	end
end                                           Proto.GameAccounts = GameAccounts

-------------------------------------------------------------------------------
-- This returns a megaiterator for going over all WoW game accounts that are
--  logged in in your friends list.
-- Iterator returns `fullname`, `faction` (single char), `gameid`
local function FriendsGameAccounts()
	local friend = 1
	-- 2.1.0: We used to just iterate over the "friends online" number. I
	--  noticed while testing that the 'favorite' friends appear at the top
	--  of the list regardless, and that will cut off some of the scan.
	-- Just another counterintuitive UI quirk.
	local friendscount = BNGetNumFriends()
	local account_iterator = nil

	return function()
		while friend <= friendscount do
			if not account_iterator then
				local friend_info = C_BattleNet.GetFriendAccountInfo( friend )
				if friend_info
				   and friend_info.gameAccountInfo.isOnline
				   and friend_info.gameAccountInfo.clientProgram == BNET_CLIENT_WOW
				   and friend_info.gameAccountInfo.wowProjectID == 1 then
					account_iterator = GameAccounts( friend_info.bnetAccountID )
				end
			end

			if account_iterator then
				local name, faction, id = account_iterator()
				if not name then
					account_iterator = nil
					friend = friend + 1
				else
					return name, faction, id
				end
			else
				friend = friend + 1
			end
		end
	end
end                             Proto.FriendsGameAccounts = FriendsGameAccounts

-------------------------------------------------------------------------------
-- Reads Battle.net game account info data for the gameid and turns it into a
--  fullname.
local function GetFullnameFromGameID( gameid )
	local game_info = C_BattleNet.GetGameAccountInfoByID( gameid )
	local cname, realm, faction = game_info.characterName,
	                              game_info.realmName,
	                              game_info.factionName

	-- If this game ID doesn't exist or is offline, then return `nil`.
	if not cname or cname == "" then return nil end

	-- The realm name is a human readable string, but the standard for
	--  pasting it onto a player name is to remove spaces and dashes.
	realm = realm:gsub( "[ -]", "" )
	cname = cname .. "-" .. realm
	return cname, faction
end                         Proto.GetFullnameFromGameID = GetFullnameFromGameID

-------------------------------------------------------------------------------
-- Shortcut for sending a simple Bnet addon message. `gameid` is the recipient
--  game account ID, `msg` is the text we're sending. If `secure` is set, then
--  the message will be sent over the secure channel. Keep in mind that ANY
--  user can read a "securely" transmitted message over Bnet, even if they
--  don't have the prefix registered (there are extra authentication steps for
--  Bnet transfers). `priority` is the message priority, which may be "LOW",
--  "NORMAL", "FAST", or "URGENT". Defaults to "NORMAL" (in the Comm sublayer).
local function SendBnetMessage( gameid, msg, secure, priority )
	if secure and not m_secure_code then
		DebugLog( "No secure channel for secure BNET message." )
		return
	end

	if type( msg ) == "table" then
		msg = tblconcat( msg, " " )
	end

	return Comm.SendBnetPacket( gameid, true, msg,
	                               secure and m_secure_channel, priority )

end                                     Proto.SendBnetMessage = SendBnetMessage

-------------------------------------------------------------------------------
-- Shortcut for sending a local addon message. Same-ish arguments as above.
--  `target` may be a player fullname or "P" to send to party/raid or "*" to
--  send to the local broadcast channel.
-- Renamed to SendProtoAddonMessage rather than SendAddonMessage, because the
--                  latter might be confusing (conflicts with the old WoW API).
local function SendProtoAddonMessage( target, msg, secure, priority )
	if secure and not m_secure_code then
		DebugLog( "Tried to send secure ADDON message with no secure channel.")
		return
	end

	if type( msg ) == "table" then
		msg = tblconcat( msg, " " )
	end

	return Comm.SendAddonPacket( target, true, msg,
	                                secure and m_secure_channel, priority )

end                         Proto.SendProtoAddonMessage = SendProtoAddonMessage

-------------------------------------------------------------------------------
-- GAME CHANNEL UTILITY FUNCTIONS
-------------------------------------------------------------------------------
-- Returns true if the user is currently joined with the channel of `name`.
--
local function GameChannelExists( name )
	return GetChannelName( name ) ~= 0
end                                 Proto.GameChannelExists = GameChannelExists

-------------------------------------------------------------------------------
-- Addons joining channels is pretty sketchy, because unless you wait an
--  indecent amount of time to join the channel, you could be bumping down
--  channel numbers that the user expects to be maintained. With more recent
--  version of the WoW client, you can swap channels, so this function moves
--                             the channel specified to the bottom of the list.
local function MoveGameChannelToBottom( name )

	local index = GetChannelName( name )
	local last_channel = index
	if index == 0 then return end

	-- There might be gaps in the channel list for whatever reason, so we scan
	--  the entire channel list for the last channel.
	for i = last_channel, MAX_WOW_CHAT_CHANNELS do
		if GetChannelName( i ) ~= 0 then
			last_channel = i
		end
	end

	for i = index, last_channel-1 do
		C_ChatInfo.SwapChatChannelsByChannelIndex( i, i + 1 )
	end
end                     Proto.MoveGameChannelToBottom = MoveGameChannelToBottom

-------------------------------------------------------------------------------
-- Tries to join a game channel, and usually succeeds unless something crazy
--  is wrong, like the user being in 20 channels already, or the channel being
--  password protected. `name` is the name of the channel, i.e. /join name.
--  `onjoin` is a callback function that will be triggered when the channel is
--             successfully joined. `retries` is an internal (recursion) value.
local function JoinGameChannel( name, onjoin, retries )
	if GameChannelExists( name ) then
		-- Channel exists, our job is done. Move it to the bottom of the
		--  channel list and pass execution to callback.
		MoveGameChannelToBottom( name )
		if onjoin then
			return onjoin( name )
		end
	else
		if retries and retries <= 0 then
			if name == Me.data_channel then
				Me.Print( "Error: couldn't join broadcast channel." )
			else
				Me.Print( "Error: couldn't join channel '%s'.", name )
			end
			return
		end
		JoinTemporaryChannel( name )

		-- Delay one second and continue with recursion, up to 10 retries.
		--  (or 9???)
		-- `onjoin or false` - We don't pass nil arguments to the timer
		--  function as it might confuse the table unpacking when passing the
		--  args to the callback.
		Me.Timer_Start( "joinchannel_" .. name, "push", 1.0,
		          JoinGameChannel, name, onjoin or false, (retries or 10) - 1 )
	end
end                                     Proto.JoinGameChannel = JoinGameChannel

-------------------------------------------------------------------------------
-- Leave a game channel. This isn't used - from older designs that used
--  different broadcast channels for security. Just a complement to our
--  channel joining function (most importantly, it cancels the joining timer).
local function LeaveGameChannel( name )
	Me.Timer_Cancel( "joinchannel_" .. name )
	if GameChannelExists( name ) then
		LeaveChannelByName( name )
	end
end                                   Proto.LeaveGameChannel = LeaveGameChannel


-------------------------------------------------------------------------------
-- BRIDGING/LINKING
-------------------------------------------------------------------------------
-- Returns true if the user specified can take us to `destination`. Used to
--  validate a bridge when we get a status message from them (a status response
--  may mean that we sent our message to an invalid route).
-- For example, after selecting a bridge and sending a routed message to it,
--  the opposite end might refuse the message and instead send us their status,
--  which means that they can't send to the destination. When we receive a
--  status message, we check over our senders and then validate the bridges
--  used (after our bridge list is updated with the status message).
-- Senders that aren't guarantee stay alive for a few seconds to wait for
--  things like this; another thing that can trigger a re-send for non
--  "guaranteed" messages is sending to an offline player (and seeing the
--                                                    system message response).
local function BridgeValid( destination, secure, fullname )
	-- For most utility functions, we avoid using things like string methods,
	--          for speed, as utility functions are often found in inner loops.
	local band = strmatch( destination, "[^%d%s]*(%d+[AH])" )
	band = GetLinkedBand( band )
	local bridge = m_bridges[band]
	if not bridge then return end
	return bridge:KeyExists( fullname, secure and "secure" )
end                                             Proto.BridgeValid = BridgeValid

-------------------------------------------------------------------------------
-- Selects a bridge that can reach `destination`. If `secure` is set, then it
--  only selects secure bridges - users that we have verified to be in our
--                                                                secure group.
local function SelectBridge( destination, secure )
	local band = strmatch( destination, "[^%d%s]*(%d+[AH])" )
	band = GetLinkedBand( band )
	local bridge = m_bridges[band]
	if not bridge then return end
	return bridge:Select( secure and "secure" )
end                                           Proto.SelectBridge = SelectBridge

-------------------------------------------------------------------------------
-- Selects a link that can reach `destination`. Normally this is called from
--  the R1 routing message, to find a link to continue to destination, but it
--  can also be called from Proto.Send, when we select ourselves as a bridge
--  (and we just bypass the R1 message).
-- Sometimes this might fail if our link to the destination goes offline or
--  something, and unfortunately the message likely needs to be just dropped,
--  as we don't have a direct connection, and in that case we reply to the
--  user that we're routing for with our status to let them update us and then
--  pick another bridge.
-- If `secure` is set, this only selects links that we have verified to be in
--                                                           our secure group.
local function SelectLink( destination, secure )
	local user, band = strmatch( destination, "([^%d%s]*)(%d+[AH])" )
	band = GetLinkedBand( band )
	local link = m_links[band]
	if not link then return end

	if user ~= "" then
		-- This is  a routing optimization. If the destination has a user set,
		--  then we can try targeting them for the R2 message, and then they
		--     don't need to send an R3 message, as they're the final endpoint.
		local direct = link:HasBnetLink( destination )
		if direct then return direct end
	end

	return link:Select( secure and "secure" )
end                                               Proto.SelectLink = SelectLink

-------------------------------------------------------------------------------
-- The self bridge is our name added into the bridge lists. We update it
--                                             whenever we gain or lose a link.
local function UpdateSelfBridge()
	local loads = {}

	-- Similar operation to us generating a status message and then handling
	--  it.
	for band, set in pairs( m_links ) do
		local avg = set:GetLoadAverage()
		if avg then
			if m_secure_code then
				if set:SubsetCount( "secure" ) > 0 then
					loads["#"..band] = "secure"
				end
			end
			loads[band] = avg
			if not m_bridges[band] then
				m_bridges[band] = Me.NodeSet.Create( {"secure"} )
			end
		end
	end

	-- And then update them.
	for band, bridge in pairs( m_bridges ) do
		local load = loads[band]
		if load then
			bridge:Add( Me.fullname, load, loads["#"..band] )
		else
			bridge:Remove( Me.fullname )
		end
	end
end                                   Proto.UpdateSelfBridge = UpdateSelfBridge

-------------------------------------------------------------------------------
-- `gameid` is Bnet game account ID, `load` is how many users the link is
--                            connected to. Triggered by the `HI` BNET message.
local function AddLink( gameid, load )
	load = load or 99
	local game_info = C_BattleNet.GetGameAccountInfoByID( gameid )
	local charname, realm, faction = game_info.characterName,
	                                 game_info.realmName,
	                                 game_info.factionName

	faction = strsub( faction or "", 1, 1 )
	if (not charname or charname == "") or (faction ~= "A" and faction ~= "H") then
		-- This player is appearing offline, or something else went wrong.
		--  Ignore the update message, as we have no idea where it's from.
		return
	end
	DebugLog2( "Adding link.", charname, realm, gameid )

	if not charname or charname == "" then
		-- Sometimes we might not be able to pull their data. This is a fairly
		--  slim corner case, where we get their message after they log out
		--  or something similar.
		return
	end

	-- Normalize realm and append to character name.
	realm = gsub( realm, "[ -]", "" )
	charname = charname .. "-" .. realm

	local band = DestFromFullname( "-" .. realm, faction )
	if IsDestLinked( band, m_my_band ) then
		-- We're not supposed to be sent HI messages from the same band.
		--  Likely will never happen, but it might due to some weird network
		--  hiccup (or malicious data).
		return
	end

	band = GetLinkedBand( band )

	if not m_links[band] then
		m_links[band] = Me.NodeSet.Create( { "secure" } )
	end

	local subset
	-- `m_node_secure_data` records whatever secure data we see, and it's easy
	--  access and optimized to let us know if any player (fullname) or
	--                                    game account is on a secure channel.
	if m_node_secure_data[gameid] and m_node_secure_data[gameid].secure then
		subset = "secure"
	end

	-- `link_ids` is links that are actively hosting.
	m_link_ids[gameid] = true

	m_links[band]:Add( gameid, load, subset )

	UpdateSelfBridge()
end                                                     Proto.AddLink = AddLink

-------------------------------------------------------------------------------
-- Removes a player link from our link sets. Examples of how this is called are
--  when a link goes offline, when a link sends us a BYE message (when they
--      /reload), or when they stop hosting (sending a HI message with 0 load).
-- `unset_crossrp` clears the Cross RP user tag for their game ID. Essentially,
--  if this is triggered from a normal status message, they still have Cross RP
--  and should be treated as such; but if they go offline or send us a BYE
--      message, then they might not have Cross RP after, so we clear the flag.
local function RemoveLink( gameid )
	DebugLog2( "Removing link.", gameid )
	for k, v in pairs( m_links ) do
		if v:Remove( gameid ) then
			m_status_broadcast_time = 0
			m_status_broadcast_fast = true
		end
	end
	m_link_ids[gameid] = nil

	UpdateSelfBridge()
end                                               Proto.RemoveLink = RemoveLink

-------------------------------------------------------------------------------
-- Update a bridge with data we've received from an ST message. `sender` is
--  a fullname. `bands` is a list of bands that they can handle for us, in the
--  status format, e.g. "1A1 #1H2", the hash means they can contact that
--  destination securely (with their secure key).
-- We don't pass secure data into here, because it's updated in another method
--            before this call. We just read m_node_secure_data for the sender.
local function UpdateBridge( sender, bands )
	-- All of the bands in here should be LINKED bands. If they aren't, then it
	--  won't really cause /much/ trouble (because we will never select bad
	--  bands).
	local loads = {}
	local secure_bridge = m_node_secure_data[sender] and
	                                          m_node_secure_data[sender].secure
	for secure, band, load in bands:gmatch( "(#?)(%d+[AH])([0-9]+)" ) do
		-- Each entry is <securemark><realmid><faction><load>.
		load = tonumber( load )

		if load < 1 or load > 99 then
			-- Basically, the user gave us some invalid data, so just treat
			--                                 them as an invalid/empty bridge.
			wipe( loads )
			break
		end

		loads[band] = tonumber( load )
		if secure_bridge and secure ~= "" then
			loads["#" .. band] = "secure"
		end

		-- Create any bridge sets that don't exist.
		if not m_bridges[band] then
			m_bridges[band] = Me.NodeSet.Create( {"secure"} )
		end
	end

	for band, bridge in pairs( m_bridges ) do
		local load = loads[band]
		if load then
			bridge:Add( sender, load, loads["#" .. band] )
		else
			bridge:Remove( sender )
		end
	end
end                                           Proto.UpdateBridge = UpdateBridge

-------------------------------------------------------------------------------
-- Remove a bridge from our registry. Examples of sources calling this are when
--  a client times out, when a client stops hosting, when a client loses all of
--                        their links, or when a client failed a message on us.
local function RemoveBridge( sender )
	for band, bridge in pairs( m_bridges ) do
		bridge:Remove( sender )
	end
end                                           Proto.RemoveBridge = RemoveBridge


-------------------------------------------------------------------------------
-- SENDING
-------------------------------------------------------------------------------
-- This is the main function to process a sender's UMID (and send it). Senders
--  usually only have one UMID, but for some messages there can be UMIDs for
--                 all bands, such as RP chat which is broadcast to everywhere.
local function ProcessSenderUMID( sender, umid )

	-- Local caches for speed. Accessing local variables is like 5 times
	--  faster.
	local data = sender.umids[umid]
	local datatime,  sendermsg,  guarantee,        datatries,  time, datadest =
	      data.time, sender.msg, sender.guarantee, data.tries, GetTime(),
		                                                             data.dest

	-- If `time` isn't set, then we need to send this message. `time` can be
	--  reset if the message needs to be resent due to failures.
	-- If this is a "guaranteed" message, then we also pass this condition to
	--  "re-send" if the ack times out. The timeout for that depends on how
	--  long the message being sent was (because longer messages can take quite
	--                                              a longer time to transfer).
	if not datatime or (guarantee and time > datatime +
	                      ACK_TIMEOUT + ACK_TIMEOUT_PER_BYTE * #sendermsg) then
		if datatries >= 5 then
			-- We've already tried to send this message 5 times, so we give up.
			--  Something is wrong.
			if sender.callback then
				sender.callback( sender, "TIMEOUT", data )
			end
			-- Resetting the `umid` entry basically cancels this sending task.
			sender.umids[umid] = nil
			return
		end

		-- I'm not actually entirely sure why we would have "local" data being
		--  sent from one of these. Completion sake, I guess?
		if IsDestLocal( datadest ) then
			if sender.ack then
				-- Ack messages shouldn't be sent locally.
				error( "Internal error." )
			end
			local localplayer = strmatch( datadest, "([^%d%s]*)%d+[AH]" )
			local target

			if localplayer ~= "" then
				target = DestToFullname( datadest )
			else
				target = "*"
			end

			-- R0 is basically a simple wrapper. Doesn't need any routing info
			--  added because the source is the sender and the destination is
			--                  the receiver, just like a normal addon message.
			SendProtoAddonMessage( target, {"R0", sender.msg}, sender.secure,
			                                                  sender.priority )
			if sender.callback then
				sender.callback( sender, "LOCAL_SENT", data )
			end
			sender.umids[umid] = nil
			return
		end

		-- If `r1_bridge` is set, then we're re-sending this message after a
		--  failure. We disable that bridge until they send us another status
		--  message. (If it's not the bridge's fault, then unset `r1_bridge`
		--                                                     to preserve it.)
		local r1_bridge = data.r1_bridge
		if r1_bridge and r1_bridge ~= Me.fullname then
			-- This bridge failed us...
			RemoveBridge( r1_bridge )
			data.r1_bridge = nil
		end

		-- Sending or re-sending message.

		-- Find a bridge.
		local bridge = SelectBridge( datadest, sender.secure )
		if not bridge then
			-- No available route, cancel this message with an error callback.
			if sender.callback then
				sender.callback( sender, "NOBRIDGE", data )
			end
			sender.umids[umid] = nil
			return
		end

		-- Flags are a string of characters attached to a message. Currently
		--  includes these:
		--   'G'  Guarantee - An ack is requested from the last router.
		--
		local flags = guarantee and "G" or "-"

		if bridge == Me.fullname then
			local link = SelectLink( datadest, sender.secure )
			if not link then
				if sender.callback then
					sender.callback( sender, "NOBRIDGE", data )
				end

				-- This should be a logical error, as we SHOULD have link data
				--  if we are a valid bridge selected above. Something wasn't
				--                                                     updated.
				Me.DebugLog( "Should have link here. Investigate." )
				sender.umids[umid] = nil
				return
			end

			if sender.ack then
				-- A2 (acknowledgement checkpoint 2) format is:
				--  "A2 [UMID] [DESTINATION]"
				SendBnetMessage( link, {"A2", umid, datadest},
				                               sender.secure, sender.priority )
			else
				-- R2 (routing checkpoint 2) format is:
				--  "R2 [UMID] [FLAGS] [SOURCE] [DESTINATION] [DATA..."
				SendBnetMessage( link,
				         {"R2", umid, flags, m_my_dest, datadest, sendermsg},
						                       sender.secure, sender.priority )
			end

		else
			-- R1 (routing checkpoint 1) format is:
			--  "R1 [UMID] [FLAGS] [DESTINATION] [DATA..."
			-- R1 doesn't have a source field, because the source is always
			--  the sender.
			-- A1 (acknowledgement checkpoint 1) format is:
			--  "A1 [UMID] [DESTINATION]"
			-- Basically, ack messages are routing messages but stripped of any
			--  message overhead.
			if sender.ack then
				SendProtoAddonMessage( bridge, {"A1", umid, datadest},
				                               sender.secure, sender.priority )
			else
				SendProtoAddonMessage( bridge,
				         {"R1", umid, flags, datadest, sendermsg},
				                               sender.secure, sender.priority )
			end

			-- Save the bridge used, so that if there's a failure, we can
			--  disable them.
			data.r1_bridge = bridge
		end

		data.tries = datatries + 1
		data.time  = time

		-- The "SENT" event does not guarantee delivery. For guaranteed
		--  messages, the "CONFIRMED" event is after the acknowledgement
		--  is received.
		if sender.callback then
			sender.callback( sender, "SENT", data )
		end
	elseif datatime and
	                 (not guarantee and time >= datatime + ONLINE_TIMEOUT) then
		-- This is for non guaranteed messages (which are most common),
		--  otherwise this bit is done after the ACK is received.
		-- The "DONE" event is triggered after a sender is completely
		--  done, and there will be no further callbacks for that sender.

		-- What's happening here, is we waited a short amount of time after
		--  sending. This wait is just to catch if we're sending to an offline
		--  player or an invalid route. In the first case, we intercept the
		--  system message, remove the bridge, and then retry (by scanning our
		--  sender list and resetting any that were using that bridge). In the
		--  second case, the R1 checkpoint will reply to us a ST message, and
		--  if we see that they no longer have the link required in their ST
		--                     message, then we reset the sender and try again.

		-- Anyway, if the short wait expires, then we assume that the message
		--               went through (it may fail later down the line though).
		sender.umids[umid] = nil
		if not next( sender.umids ) then
			m_senders[sender] = nil
			if sender.callback then
				sender.callback( sender, "DONE" )
			end
		end
	end
end                                 Proto.ProcessSenderUMID = ProcessSenderUMID

-------------------------------------------------------------------------------
-- Update function for senders. Called periodically by Proto.Update, and also
--  called when a sender is changed by other methods and events related to its
--  operation.
local function ProcessSender( sender )
	-- Don't process this sender if it was removed from the sender table
	--  already.
	if not m_senders[sender] then return end

	for umid, _ in pairs( sender.umids ) do
		ProcessSenderUMID( sender, umid )
	end

	-- Check if m_senders[sender] is unset already before triggering this, as
	--  that can be done in the child function. Right now we don't really need
	--                            this bit, and it's more of just a safety net.
	if not next(sender.umids) and m_senders[sender] then
		m_senders[sender] = nil
		if sender.callback then
			sender.callback( sender, "DONE" )
		end
	end
end                                         Proto.ProcessSender = ProcessSender

-------------------------------------------------------------------------------
-- This is called when we receive an ST message from someone. We check over our
--  senders, and any that were using that someone verifies if the bridge is
--  still valid for the destination they want to reach. Routers can especially
--  respond with an ST message when they can't reach the destination we want.
-- This is rare, because ST is also broadcast fairly instantly when a bridge
--  loses a destination band entirely. `route_fullname` is the fullname of the
--                                                    sender of the ST message.
local function CheckSenderRoutes( route_fullname )
	-- It'll probably be pretty common that we aren't sending anything, because
	--  there can be a lot of status messages that trigger in a high population
	--  setting.
	if not next(m_senders) then return end

	-- Copy our sender table, because the ProcessSender function might leave it
	--  in a bad state for iterating.
	local senders_copy = {}
	for _, sender in pairs( m_senders ) do
		senders_copy[ #senders_copy ] = sender
	end

	for _, sender in pairs( senders_copy ) do
		local process = false
		for umid, data in pairs( sender.umids ) do
			-- `r1_bridge` is the fullname of the bridge we chose to start
			--  routing.
			if data.r1_bridge == route_fullname then
				if not BridgeValid( data.dest, sender.secure, data.r1_bridge ) then
					-- Found an invalidated bridge, and we need to resend.
					data.time      = nil
					data.r1_bridge = nil

					-- Undo the try, because we caught something wrong.
					data.tries = data.tries - 1
					process    = true
				end
			end
		end

		-- Overall, this function (CheckSenderRoutes) seems fairly heavy for
		--  something that's triggered for every status message; but most of
		--                  these conditions are rare and it should be minimal.
		if process then
			ProcessSender( sender )
		end
	end
end                                 Proto.CheckSenderRoutes = CheckSenderRoutes

-------------------------------------------------------------------------------
-- This generates a new UMID, using our prefix and incrementing serial. Used
--  whenever we are about to send a message to a destination. UMIDs are unique
--  per message and destination, but they may be reused if the same message is
--  being re-sent.
local function GenerateUMID()
	local umid = m_umid_prefix .. m_next_umid_serial
	m_next_umid_serial = m_next_umid_serial + 1
	return umid
end                                           Proto.GenerateUMID = GenerateUMID

-------------------------------------------------------------------------------
-- Triggered when we receive an A3 message, or an A2 message with us as the
--  destination. Basically tells us that a UMID was received by the last
--  routing point and our message should have been received by the final
--  destination (unless they have logged off or something). In particular, acks
--  are sent AFTER the R3 is put out on the line, so if we see the A3, then
--                                 the R3 most definitely went through as well.
local function OnAckReceived( umid )
	DebugLog( "Got ACK for %s.", umid )
	for k, sender in pairs( m_senders ) do
		for sender_umid, data in pairs( sender.umids ) do
			if sender_umid == umid then
				-- "CONFIRMED_DEST" is triggered when we receive an ack for a
				--  UMID we have sent out. "CONFIRMED" is also triggered, but
				--  only after a sender is entirely finished (for senders with
				--  multiple destinations). "DONE" is also still triggered for
				--           "guaranteed" senders, when everything is finished.
				sender.umids[umid] = nil
				if sender.callback then
					sender.callback( sender, "CONFIRMED_DEST", data.dest )
				end

				if not next( sender.umids ) then
					if sender.callback then
						sender.callback( sender, "CONFIRMED" )
						sender.callback( sender, "DONE" )
					end
					m_senders[sender] = nil
				end
				return
			end
		end
	end

	-- This isn't really an error down here, because with high network
	--  congestion, we might get two ACKs if we happen to send a message twice
	--  just because of high latency (both go through, but just take a long
	--  time).
	DebugLog( "Got ACK but couldn't match the UMID (%s).", umid )
end                                         Proto.OnAckReceived = OnAckReceived

-- Converting the localized message for
--  "No player named ... is currently playing."
-- into a Lua pattern to extract the name. Better compatibility than having
--  localized patterns ourself (but hopefully our conversion pattern here
--  works for all locales).
local SYSTEM_PLAYER_NOT_FOUND_PATTERN =
                              ERR_CHAT_PLAYER_NOT_FOUND_S:gsub( "%%s", "(.+)" )

-------------------------------------------------------------------------------
-- Handler for CHAT_MSG_SYSTEM game event. The only system message we're
--    interested in is the one that triggers from sending to an offline player.
local function OnChatMsgSystem( event, msg )
	if not Proto.startup_complete then return end

	local name = strmatch( msg, SYSTEM_PLAYER_NOT_FOUND_PATTERN )
	-- This might be an ambiguated name, and in that case we won't end up doing
	--  anything because our senders always use fullnames.
	if name then
		DebugLog( "Removing offline player %s.", name )
		RemoveBridge( name )
		local to_process
		for k, sender in pairs( m_senders ) do
			for sender_umid, data in pairs( sender.umids ) do
				if data.r1_bridge == name then
					data.time = nil

					-- Update this sender.
					to_process = to_process or {}
					to_process[#to_process] = sender
				end
			end
		end

		if to_process then
			for _, sender in pairs( to_process ) do
				ProcessSender( sender )
			end
		end
	end
end                                     Proto.OnChatMsgSystem = OnChatMsgSystem

-------------------------------------------------------------------------------
-- This is our main sending API. The simplest example of using this is:
--   Proto.Send( "Catnia1H", "hoi" )
-- This will send the message "hoi" to Catnia on Moon Guard (1) Horde, no
--  matter where you are located, so long as you have a bridge to that band.
-- To receive the message, it must be registered through
--  `Proto.SetMessageHandler`.
-- e.g. `Proto.SetMessageHandler( "hoi", MyHandler )`
--
-- `dest` can be:
--   - "local"  Send (broadcast) to our Cross RP channel.
--   - "all"    Send (broadcast) to all bands that we know of.
--   - "active" Send (broadcast) to all bands that we ahve touched recently.
--   - <band>   A band name sends a broadcasted message to that band.
--   - <dest>   A complete destination sends a whispered message to that user.
--   - <local dest> A local destination is something that "works" but that's
--               just an odd request.
-- `msg` can either be a table or a string. If it's a table, the resulting
--  message is the entries concatenated together with spaces.
-- `options` is an optional table with all entries inside optional:
--    secure     Boolean - send securely.
--    priority   "LOW", "NORMAL", "FAST", or "URGENT" for the Comm layer.
--    guarantee  Basically guarantees delivery, resending if it fails (requests
--                an ACK from the routers).
--    callback   A callback to receive events about the sending status.
-- The callback function has the signature ( sender, event, data )
--   `sender` is the sender object. It will mirror the same fields that are
--    in the `options` passed in, so you can share userdata that way (just
--    watch out for internal data). `data` is the per-destination data,
--    containing the UMID and other things like time sent, what bridge, etc.
-- Events can be triggered at the sender level or the destination level. A
--  sender only has one message, but it can mirror that message to multiple
--  destinations. Per-destination events are as follows:
--    TIMEOUT     Sending failure due to unknown network problems. (NOT sure
--                 if the message went through or not).
--    LOCAL_SENT  A message was sent locally (and no further verification will
--                 be done for that message.
--    NOBRIDGE    Couldn't send to a destination, because we have no bridge
--                 for them. (Likely became unavailable after the sending
--                 started).
--    SENT        A message was put out on the line. Multiple SENTs can be
--                 triggered, for each attempt we send the data.
--    CONFIRMED_DEST  This is triggered after we receive an ACK for a single
--                     destination.
-- Per-sender events are as follows:
--    DONE        Triggered when a sender is completely done. This is always
--                 the final event.
--    CONFIRMED   Triggered when a sender has been ack'd completely, meaning a
--                 guaranteed message was transferred successfully. "DONE"
--                 followsimmediately after.
-- Finally, one thing to really keep in mind, that while this is super
--  convenient and all, this routing protocol is based upon TRUST. There are
--  a lot of opportunities for man-in-the-middle attacks or falsified
--  information being passed around. Due to this very reason, we do not
--  endorse any type of "global" Cross RP chat, as impersonation would be both
--                                       too easy to do, and too hard to trace.
local function Send( dest, msg, options )
	options = options or {}
	local secure = options.secure
	if secure and not m_secure_code then
		DebugLog2( "Tried to send secure message outside of secure mode." )
		return
	end

	if type(msg) == "table" then
		msg = tblconcat( msg, " " )
	end

	-- Local dest, which translates to a single message to our local band.
	if dest == "local" then dest = { m_my_band } end

	if dest == "all" or dest == "active" then
		-- "all" and "active" transfer to all bands we know, or any active
		--  bands we know.
		local send_to = { m_my_band }
		local time = GetTime()
		for k, v in pairs( m_bridges ) do
			if not v:Empty( secure and "secure" ) then
				local active =
				            time < (m_active_bands[k] or 0) + BAND_TOUCH_ACTIVE
				if dest == "all" or active then
					table.insert( send_to, k )
				end
			end
		end

		dest = send_to
	end

	-- `dest` may be a string, meaning a single destination, so wrap that
	--  in a table.
	if type(dest) == "string" then dest = {dest} end

	-- We reuse the options table as our sender object.
	local sender = options
	sender.umids = dest -- And we reuse the `dest` table as our umid table.
	sender.msg   = msg

	for i = 1, #dest do
		-- Populate our UMID table, each one of these is a message that
		--  we need to send. One per band for broadcasts, and one per player
		--  that we whisper. Currently there aren't any multi-whisper types
		--                                          of messages in our program.
		local umid = GenerateUMID()
		dest[umid] = { umid = umid, dest = dest[i], tries = 0 }
		dest[i] = nil
	end

	m_senders[sender] = sender
	ProcessSender( sender )
end                                                           Proto.Send = Send

-------------------------------------------------------------------------------
-- Registers a handler for a message type. Triggered when we receive a message
--  through the routing protocol.
-- The `command` is the first word of the message (e.g. "RP1" for an RP chat
--  message). The signature of the handler is `( source, text, complete )`.
-- `source` is the message's source, a player "destination". `text` is the
--  message contents. For short messages, `complete` will always be true. For
--  longer messages, `complete` may be false, which means the callback is being
--  triggered for transfer progress, and can be triggered multiple times like
--  that. If you're only interested in complete messages, make sure this is
--  true.
-- When `complete` is false, you are still guaranteed the first chunk of the
--  message, so you can read header data and act accordingly (to display a
--  transfer-in-progress message or some such).
-- The handler can only trigger once with `complete` true. For short messages
--  that fit into a single chunk, `complete` will always be true, and you don't
--  need to check it.
local function SetMessageHandler( command, handler )
	m_message_handlers[command] = handler
end                                 Proto.SetMessageHandler = SetMessageHandler

-------------------------------------------------------------------------------
-- Currently only one handler can be registered per command.
local function GetMessageHandler( command )
	return m_message_handlers[command]
end                                 Proto.GetMessageHandler = GetMessageHandler

-------------------------------------------------------------------------------
-- Called from our R3 or R2 (with us as the destination) to process a routed
--  message received.
local function OnMessageReceived( source, umid, text, job )
	-- I think it might be possible to receive a message even if we haven't
	--                   finished initialization. In that case, just ignore it.
	if not Proto.startup_complete then return end
	local prefix, complete = job.prefix, job.complete

	if umid and complete then
		local time = GetTime()
		local sumid = source .. "-" .. umid
		local seen = m_seen_umids[sumid]
		if seen and time < seen + 60*10 then
			-- We might get duplicate messages if they are resent due to network
			--  problems, so we filter them out here. Only process them once.
			DebugLog2( "Ignoring duplicate UMID." )
			return
		end

		-- This table is cleaned up in a routine function.
		m_seen_umids[sumid] = time
	end

	DebugLog2( "Proto Msg", complete, source, text )
	local command = strmatch( text, "^%S+" )
	if not command then return end
	if prefix ~= "" and m_secure_channel ~= prefix then
		-- If this happens, someone might have outdated information of us, or
		--  there is a larger logical concern somewhere that needs to be fixed.
		DebugLog2( "Got secure message, but we aren't listening to it." )
		return
	end

	local secure = m_secure_code and prefix == m_secure_channel

	-- Pass the message to the registered handler.
	local handler = m_message_handlers[command]
	if handler then
		handler( source, text, complete, secure )
	end
end                                 Proto.OnMessageReceived = OnMessageReceived


-------------------------------------------------------------------------------
-- STATUS
-------------------------------------------------------------------------------
-- Sends an ST (status) message. This message is what tells other clients that
--  they can use us as a bridge (or if they can no longer use us as a bridge,
--                              if our links go offline or if we stop hosting).
-- `target` may be `nil` or a local player (fullname). If it's a player, our
--  status is whispered to them. This is done especially when a player logs in
--  and requests everyone's status (`do_request`). Otherwise, the status is
--  broadcast to our local channel.
-- `priority` is what priority we use for this status. Defaults to "NORMAL",
--  but there are some special circumstances that cause broadcasts to go at a
--  higher priority (like when we lose a link, we want that to be "FAST".
-- `do_request` sets the request bit in the status, causing anyone who sees the
--  broadcast message to reply to us by whispering their status.
--
-- Currently status is sent in three cases:
--  * Periodic broadcast to update players. (If we don't do this, the players
--     will treat us as "timed out" and not send us any data).
--  * As a whispered response to ST messages with the request flag set.
--  * As a whispered response to players who try to route messages through us
--     but we can't reach the destination.
local function BroadcastStatus( target, priority, do_request )
	local secure_hash1, secure_hash2 = "-", "-"
	local bands = "-"

	if m_hosting then
		bands = {}
		if m_secure_code then
			secure_hash1, secure_hash2 = strsub( m_secure_hash, 1, 12 ),
										  strsub( m_secure_myhash, 1, 8 )
		end
		-- Building a list of bands in the format <#><band><load>, colon
		--  separated. Load is the average load of all of our links. This isn't
		--  super optimal; it's simple. The hash prefix is for any "secure"
		--  links we have, meaning that we have verified them to be using the
		--     same secure credentials that we are broadcasting (hash1, hash2).
		for band, set in pairs( m_links ) do
			local avg = set:GetLoadAverage()
			if avg then
				local secure_mark = ""
				if m_secure_code then
					if set:SubsetCount( "secure" ) > 0 then
						secure_mark = "#"
					end
				end
				if not Me.active then
					-- If we aren't actively Cross RPing, then increase our
					--  load to deter people using us as a bridge.
					avg = min( avg * 2, 99 )
				end
				bands[#bands + 1] = secure_mark .. band .. avg
			end
		end
		bands = tblconcat( bands, ":" )
		if bands == "" then bands = "-" end
	end

	-- The request bit of the status message is "-" or "?"
	local request = "-"
	if not target and do_request then
		request = "?"
	end

	if bands == "-" then
		-- We don't repeatedly broadcast empty status messages. If a user isn't
		--  hosting, or has no links, they only send the "empty" status once,
		--                          and then wait until they are a useful host.
		if m_status_last_sent_empty then
			return
		end

		m_status_last_sent_empty = true
	else
		m_status_last_sent_empty = false
	end

	local priority = priority or "NORMAL"

	if not target then
		-- This stuff is only for our periodically broadcast status.
		-- Cancel any previous status message pending, which could be a
		--  "disabled" status that might be in the queue.
		Comm.CancelSendByTag( "st" )
		-- `status_broadcast_fast` is set when we lose a link, so we prioritize
		--  sending our status to prevent them from trying to route over that
		--  lost link.
		priority = m_status_broadcast_fast and "FAST" or priority
		m_status_broadcast_fast = false
	end

	-- Status format is:
	--  ST [VERSION] [REQUEST] [SECUREHASH1] [SECUREHASH2] [BANDLIST]
	-- [VERSION] is our Cross RP version in full.
	-- [REQUEST] is "-" or "?", "?" means we are requesting everyone's status.
	-- [SECUREHASH] are for secure-mode, letting people know that we are in
	--               their secure group.
	-- [BANDLIST] is a colon separated band list, containing the band ID and a
	--             load number, so people can do some load balancing when
	--             selecting bridges.
	DebugLog2( "Sending status.", target )
	local job = SendProtoAddonMessage( target or "*",
	          {"ST", Me.version, request, secure_hash1, secure_hash2, bands},
			       false, priority )
	-- Tag this as "st" so we can cancel it in the queue if we overwrite it
	--  with a newer status message, or a disabled/logout message.
	job.tags = { st = true }
end                                     Proto.BroadcastStatus = BroadcastStatus

-------------------------------------------------------------------------------
-- Sends "HI" messages over Battle.net; this message is basically our status
--  message meant for links, sent during login to probe our friends list, as
--  well as sent periodically to let them know we're still alive.
-- `gameids` is either a table of gameids that we should send our HI message
--  to. The VALUES of this table are ignored, and only the keys matter.
--  i.e. `table[gameid_to_send_to] = true`
-- `request` makes the message a request type, meaning that whoever receives it
--  will respond with another HI message, a status reply.
-- `load_override` overwrites the reported load we have, set during
--  initialization to something higher than normal so we don't get a burst of
--  traffic if we're about to end up as a "heavy-load" node.
-- `priority` is the Comm priority to send this message. Defaults to "LOW".
--
local function SendHI( gameids, request, load_override, priority )
	if type(gameids) == "number" then
		gameids = {[gameids] = true}
	end

	local load
	if m_hosting then
		load = min( max( load_override or #m_links, 1 ), 99 )

		-- If we aren't actively Cross RPing, then we're in low power mode,
		--  i.e. try and tell people to use another link.
		if not Me.active then
			load = min( load * 2, 99 )
		end
	else
		load = 0
	end

	local short_passhash = strsub( m_secure_hash or "-", 1, 12 )
	local passhash       = strsub( m_secure_myhash or "-", 1, 8 )

	local request_mode = request and "?" or "-"

	-- Format for the Bnet status message is:
	--  HI [VERSION] [REQUESTBIT] [LOAD] [HASH1] [HASH2]
	-- [VERSION] is our full Cross RP version.
	-- [REQUESTBIT] is "?" if we are requesting everyone's status.
	-- [LOAD] is how many links we have.
	-- [HASH1]/[HASH2] are our secure hashes.

	for id, _ in pairs( gameids ) do
		local job = SendBnetMessage( id,
		     {"HI", Me.version, request_mode, load, short_passhash, passhash},
		                                             false, priority or "LOW" )
		job.tags = { hi = true }
	end
end                                                       Proto.SendHI = SendHI

-------------------------------------------------------------------------------
-- We call this to broadcast our Bnet status (HI) to our friends list. Sort of
--  a simple wrapper for SendHI.
-- `all` is for initialization purposes, where we send to everyone rather than
--  only to who we have registered as a Cross RP user. After initialization, we
--  maintain a list of who we have seen as a Cross RP user, and send to only
--  them. First global broadcast is a probe.
-- `request`, `load_override` and `priority` are passed to `SendHI`.
--
local function BroadcastBnetStatus( all, request, load_override, priority )
	local send_to
	-- We don't quite send to 'everyone' - only to people who are on
	--  different [linked] bands than us.
	send_to = {}
	for charname, faction, game_account in FriendsGameAccounts() do
		local realm = strmatch( charname, "%-(.+)" )
		if not m_linked_realms[realm] or faction ~= Me.faction then
			local crossrp_gameid = m_crossrp_gameids[game_account]
			if crossrp_gameid == nil then
				m_crossrp_gameids[game_account] = false
				send_to[game_account] = true
			elseif crossrp_gameid == true
			                          or (all and crossrp_gameid == false) then
				-- If `all` is set, we're probing all users. Done at startup.
				-- Otherwise, we're only probing people who we have seen with
				--  Cross RP. (`crossrp_gameids[account] == true`)
				send_to[game_account] = true
			end
		end
	end

	-- Something to watch out for here, is if we happen to cancel any pending
	--  HI messages that haven't gone out to unprobed destinations, they will
	--  forever remain invisible to us. Might happen in extreme conditions
	--  where the user has a ton of friends to probe at the start, where the
	--  requests get clogged in the queue longer than the startup wait period.
	Comm.CancelSendByTag( "hi" )
	SendHI( send_to, request, load_override, priority )
end                             Proto.BroadcastBnetStatus = BroadcastBnetStatus


-------------------------------------------------------------------------------
-- ROUTINE
-------------------------------------------------------------------------------
-- When we start hosting, we allow players to route messages through us. This
--  is the main switch ON.
local function StartHosting()
	if m_hosting then return end

	if BNGetNumFriends() == 0 then
		-- Sometimes Battle.net won't work correctly during the session, and
		--              doesn't report any friends. In that case, we can' host.
		if not Proto.warned_bnet_down then
			Proto.warned_bnet_down = true
			DebugLog2( "Battle.net is down for this session. Cannot host." )
		end
		return
	end

	m_hosting      = true
	m_hosting_time = GetTime()

	-- Trigger a status message to let people know we're started up.
	m_status_broadcast_time = 0
end                                           Proto.StartHosting = StartHosting

-------------------------------------------------------------------------------
-- This doesn't entirely stop hosting, as some players might still choose us
--  as a route until they register our status message. There's a grace period
--  that allows people to finish any messages they're busy transferring through
--  us.
local function StopHosting()
	if not m_hosting then return end
	m_hosting = false
	BroadcastStatus()
	BroadcastBnetStatus( false, false )
end                                             Proto.StopHosting = StopHosting

-------------------------------------------------------------------------------
-- Triggered during /reload or logging out. Unfortunately in the latter case,
--                          the game doesn't actually send our logout messages.
local function Shutdown()
	Comm.CancelSendByTag( "st" )

	-- Broadcast "BYE". "URGENT" means that we will call SendAddonMessage
	--                     directly in this call, bypassing the chat throttler.
	Comm.SendAddonPacket( "*", true, "BYE", nil, "URGENT" )

	-- And also broadcast "BYE" to Battle.net friends on different bands.
	for charname, faction, game_account in FriendsGameAccounts() do
		local realm = charname:match( "%-(.+)" )
		if not m_linked_realms[realm] or faction ~= Me.faction then
			Comm.SendBnetPacket( game_account, true, "BYE", nil,
			                                                         "URGENT" )
		end
	end
end                                                   Proto.Shutdown = Shutdown

-------------------------------------------------------------------------------
-- Returns true if we're currently hosting. `include_grace_period` also makes
--        us return true if we aren't hosting, but are within the grace period.
local function IsHosting( include_grace_period )
	if m_hosting then
		return true
	else
		if include_grace_period and
		               (GetTime() < m_hosting_time + HOSTING_GRACE_PERIOD) then
			return true
		end
	end
end                                                 Proto.IsHosting = IsHosting

-------------------------------------------------------------------------------
-- Called periodically, a maintenance function to clean up any old entries in
--  our `seen_umids` table.
local function CleanSeenUMIDs()
	Me.Timer_Start( "proto_clean_umids", "push", 35.0, CleanSeenUMIDs )
	local time = GetTime() - 300

	for k, v in pairs( m_seen_umids ) do
		if time > v then
			m_seen_umids[k] = nil
		end
	end
end                                       Proto.CleanSeenUMIDs = CleanSeenUMIDs

-------------------------------------------------------------------------------
-- Triggered periodically and through the BN_FRIEND_INFO_CHANGED message.
-- If we lose a path to a destination band, then we reset the status broadcast
--  timer, and call Update.
-- If `run_update` is false, we won't call `Update` (set to false when running
--  from inside `Update`).
local function PurgeOfflineLinks( run_update )
	for gameid,_ in pairs( m_crossrp_gameids ) do
		local game_info = C_BattleNet.GetGameAccountInfoByID( gameid )
		if game_info then
			local charname, realm, faction = game_info.characterName,
											 game_info.realmName,
											 game_info.factionName
			if not charname or charname == "" then
				m_crossrp_gameids[gameid] = nil
				if m_link_ids[gameid] then
					RemoveLink( gameid )
				end
			end
		end
	end

	if m_status_broadcast_time == 0 then
		m_status_broadcast_fast = true
		if run_update then
			Proto.Update() -- Global call, because Update isn't defined yet.
		end
	end
end                                 Proto.PurgeOfflineLinks = PurgeOfflineLinks

-------------------------------------------------------------------------------
local function OnLinkRemoved( gameid )
	-- Calling this function in here is a bit overkill, but it's okay because
	--  nodes expiring should be very rare. If removing links ever becomes a
	--  (much) heavier operation, then we may want to look into optimizing
	--  this.
	RemoveLink( gameid )
end

-------------------------------------------------------------------------------
-- Main routine update function. Called periodically.
local function Update()
	Me.Timer_Start( "protocol_update", "push", 1.0, Update )
	local time = GetTime()

	-- Turn hosting off when we enter an instance. It would probably be fine to
	--  leave it on, but this is just basic prudence to respect someone's time
	--  inside of a dungeon or raid (especially mythic), to not use any of
	--                                             their bandwidth for routing.
	if m_hosting then
		if IsInInstance() or HasUnsuitableLag() or Proto.hosting_disabled then
			StopHosting()
		end
		m_hosting_time = time
	else
		-- Only turn on hosting automatically if a wait period has passed since
		--  it was turned off. There's also a flag that can programmatically be
		--  set to disable hosting.
		if not IsInInstance() and time >= m_hosting_time + 300
		         and not HasUnsuitableLag() and not Proto.hosting_disabled then
			StartHosting()
		end
	end

	-- Check link health.
	for k, v in pairs( m_links ) do

		if v:RemoveExpiredNodes( OnLinkRemoved ) then
			-- The NodeSet will return true if it removes the last node in the
			--  set, meaning that we lost a link completely. In that case we
			--  want to broadcast our status immediately to let people know, to
			--                                      avoid any routing problems.
			m_status_broadcast_time = 0
			m_status_broadcast_fast = true
		end
	end

	-- Clean up any bridges that have expired. Bridges expire if they don't
	--  broadcast any status in so long. They will also be removed if we get a
	--           "player is offline" message when trying to route through them.
	for k, v in pairs( m_bridges ) do

		-- Make sure that any self-bridges aren't removed. Keep their time
		--  updated.
		local selfnode = v.nodes[Me.fullname]
		if selfnode then
			selfnode.time = time
		end
		v:RemoveExpiredNodes()
	end

	-- Clean up any offline links. Usually this will do nothing, as those will
	--                   be caught in the BN_FRIEND_INFO_CHANGED event handler.
	PurgeOfflineLinks( false )

	-- Process our senders. We don't copy this table beforehand because
	--  ProcessSender might add new keys. (We don't, but a sender callback
	--  might call Proto.Send).
	local senders_copy = {}
	for _, sender in pairs( m_senders ) do
		senders_copy[ #senders_copy ] = sender
	end
	for _, v in pairs( senders_copy ) do
		ProcessSender( v )
	end

	-- Periodic status broadcasts.
	if m_hosting
	        and time > m_status_broadcast_time + STATUS_BROADCAST_INTERVAL then
		m_status_broadcast_time = time

		-- Both on our local channel and update all of our Bnet links.
		BroadcastStatus()
		BroadcastBnetStatus()
	end
end                                                       Proto.Update = Update

-------------------------------------------------------------------------------
-- Called when we mouseover or target a unit, and we set whatever band that
--                                      unit is on to ACTIVE (record the time).
local function TouchUnitBand( unit )
	local band = GetBandFromUnit( unit )
	if not band then return end

	if not IsDestLocal( band ) then
		band = GetLinkedBand( band )
		m_active_bands[band] = GetTime()
	end
end                                         Proto.TouchUnitBand = TouchUnitBand


-------------------------------------------------------------------------------
-- SECURE CHANNEL
-------------------------------------------------------------------------------
-- Converts a number into base32. 6 digits.
local function Base32x6( number )
	local chars = "0123456789ABCDEFGHIJKLMONPQRSTUV"
	local result = ""
	for i = 1, 6 do
		local digit = 1 + (number % 32)
		number = bit.rshift( number, 5 )
		result = chars:sub( digit, digit ) .. result
	end
	return result
end

-------------------------------------------------------------------------------
-- Generates a 10 digit channel ID from our secure code, used for an addon
--  prefix (and used to be for game channel names).
local function GetSecureChannel()
	local sha1, sha2 = Me.Sha256Data( "channel" .. m_secure_code )
	local channel = Base32x6( sha1 ) .. Base32x6( sha2 )
	return channel:sub( 1, 10 )
end                                   Proto.GetSecureChannel = GetSecureChannel

-------------------------------------------------------------------------------
-- Updates secure data linked to an id, which can be a gameid or fullname (for
--  link or bridge). `hash1` is the public hash. `hash2` is the personal hash.
local function UpdateNodeSecureData( id, hash1, hash2 )
	if not hash1 or hash1 == "" or hash1 == "-" then
		-- This person doesn't have secure keys specified.
		m_node_secure_data[id] = nil
	else
		local sd = m_node_secure_data[id] or {}
		m_node_secure_data[id] = sd
		-- If anything changes, then we update it.
		if sd.code ~= m_secure_code or sd.h1 ~= hash1 or sd.h2 ~= hash2 then
			sd.code = m_secure_code
			sd.h1   = hash1
			sd.h2   = hash2

			-- `hash1` isn't really useful for anything other than
			--  optimization.
			-- Calculating the sha256 is some pretty heavy work, despite us
			--  having a fairly fast implementation for it, so we check if the
			--  `hash1` matches first before doing that.
			if m_secure_code and hash1 == strsub( m_secure_hash, 1, 12 ) then
				-- If `id` is a number, then it's a gameid, and we need a
				--                                   fullname to salt the hash.
				local name = type(id) == "number" and
				                              GetFullnameFromGameID( id ) or id
				if not name then
					sd.secure = false
					return
				end
				local hash = Me.Sha256( name .. m_secure_code )
				sd.secure = strsub( hash, 1, 8 ) == hash2
			else
				sd.secure = false
			end
		end
	end
end                           Proto.UpdateNodeSecureData = UpdateNodeSecureData

-------------------------------------------------------------------------------
-- This is only called during initialization of the secure state, and all
--  bridge and link node sets have had their "secure" tags reset. In here we
--    update our secure data and then properly tag any secure links or bridges.
local function UpdateSecureNodeSets()

	for k, v in pairs( m_node_secure_data ) do
		UpdateNodeSecureData( k, v.h1, v.h2 )
	end

	for band, bridge in pairs( m_bridges ) do
		for k, v in pairs( bridge.nodes ) do
			if m_node_secure_data[k] and m_node_secure_data[k].secure then
				bridge:ChangeNodeSubset( k, "secure" )
			end
		end
	end

	for band, link in pairs( m_links ) do
		for k, v in pairs( link.nodes ) do
			if m_node_secure_data[k] and m_node_secure_data[k].secure then
				link:ChangeNodeSubset( k, "secure" )
			end
		end
	end

	UpdateSelfBridge()
end                           Proto.UpdateSecureNodeSets = UpdateSecureNodeSets

-------------------------------------------------------------------------------
-- Used to prime the secure state system before we update the settings.
local function ResetSecureState()
	-- Erase any "secure" tags for all of our links and bridges.
	for k, v in pairs( m_links ) do
		v:EraseSubset( "secure" )
	end

	for k, v in pairs( m_bridges ) do
		v:EraseSubset( "secure" )
	end
end                                   Proto.ResetSecureState = ResetSecureState

-------------------------------------------------------------------------------
-- Enables or disables a secure state. `code` is the password used. Anyone else
--  who uses the same password for their secure state can communicate over
--  secure channels. Pass `nil` to disable the secure state.
--
local function SetSecure( code )
	ResetSecureState()
	m_secure_code = code
	if code then
		-- Enabling secure state.
		m_secure_channel = GetSecureChannel()
		m_secure_hash    = Me.Sha256( m_secure_code )

		-- The personal hash here is a way to let other people know that we
		--  actually have the password. This hash can't be copied because it's
		--  unique per player, and only people with the secure code can create
		--                                                 it with their name.
		m_secure_myhash  = Me.Sha256( Me.fullname .. m_secure_code )
		if not m_registered_addon_prefixes[m_secure_channel] then
			m_registered_addon_prefixes[m_secure_channel] = true
			C_ChatInfo.RegisterAddonMessagePrefix( m_secure_channel .. "+RP" )
		end
		UpdateSecureNodeSets()
	else
		-- Disabling secure state.
		m_secure_channel = nil
		m_secure_hash    = nil
		m_secure_myhash  = nil
	end
	m_status_broadcast_time = 0
end                                                 Proto.SetSecure = SetSecure


-------------------------------------------------------------------------------
-- PROTOCOL
-------------------------------------------------------------------------------
-- HI - Bnet status message.
-- This is a client's probe to share information about themselves, and also to
--                             request information from us, to establish links.
function Proto.handlers.BNET.HI( job, sender )
	if not job.complete then return end

	-- Parse message.
	local version, request, load, short_hash, personal_hash =
	                 strmatch( job.text, "^HI (%S+) (.) ([0-9]+) (%S+) (%S+)" )
	if not load then return false end

	SaveVersion( version, sender )

	-- Valid loads are 0-99, with 0 meaning they aren't hosting.
	load = tonumber(load)
	if load > 99 then return false end

	-- `crossrp_gameids` are game IDs that have Cross RP installed.
	m_crossrp_gameids[sender] = true

	-- Sanitize these inputs because they can be pretty wonky sometimes.
	local charname, realm, faction
	local game_info = C_BattleNet.GetGameAccountInfoByID( sender )
	if game_info then
		charname, realm, faction = game_info.characterName,
								   game_info.realmName,
								   game_info.factionName
	end
	local valid = true
	charname = charname or ""
	realm    = realm or ""
	faction  = strsub( faction or "", 1, 1 )

	-- 2.0.4: faction can also be "Neutral" for starting pandaren. We don't
	--  want any filthy neutrals. This message should no longer be received if
	--  clients update to 2.0.4, as Cross RP will disable itself in that case.

	if charname ~= "" and realm ~= "" and (faction == "A" or faction == "H") then
		-- This is a local target so this message should never be sent to
		--  us. But y'know, networking.
		if m_linked_realms[realm] and faction == Me.faction then
			Me.DebugLog2( "Got rogue HI message.", sender, charname )
			valid = false
		end
	else
		valid = false
	end

	if not valid then
		-- This is likely an offline user, but this can also happen in other
		--  rare circumstances, like someone playing a starting pandaren on an
		--  older version of Cross RP.
		-- Treat this like a BYE message.
		m_node_secure_data[sender] = nil
		m_crossrp_gameids[sender] = nil
		RemoveLink( sender )
		return
	end

	-- Update their secure data using the hashes specified. The `short_hash`
	--  is just a shortcut, lets us know if they're using the same
	--  secure code as us. That value can just be copied though, and the
	--  `personal_hash` is the second step of verification, which is generated
	--                      by hashing their fullname against the secure code.
	UpdateNodeSecureData( sender, short_hash, personal_hash )

	-- AddLink is also meant for updating or refreshing links, called
	--  periodically for healthy links.
	if load > 0 then
		AddLink( sender, load )
	else
		RemoveLink( sender )
	end

	-- If the request bit is "?", then this is sent from a user starting up,
	--  requesting status from everyone. We use FAST priority for this because
	--  they only have a few seconds before their next startup phase triggers,
	--  and if our message is too late, then we won't be registered as a link
	--                                      for their initial status broadcast.
	if request == "?" then
		SendHI( sender, false, nil, "FAST" )
	end
end

-------------------------------------------------------------------------------
-- BYE - Service shutdown. (Bnet broadcast version.)
-- This is basically a warning message that the user is /reloading their UI and
--  are in a bad state for anything. Instantly terminate them and do not use
--                    them for any operations until they reestablish stability.
function Proto.handlers.BNET.BYE( job, sender )
	-- `sender` is gameid.
	m_node_secure_data[sender] = nil
	m_crossrp_gameids[sender] = nil
	RemoveLink( sender )
end

-------------------------------------------------------------------------------
-- BYE - Service shutdown. (Local addon broadcast version.)
--
function Proto.handlers.BROADCAST.BYE( job, sender )
	-- `sender` is fullname.
	m_node_secure_data[sender] = nil
	m_crossrp_gameids[sender] = nil
	RemoveBridge( sender )
end

-------------------------------------------------------------------------------
-- ST - Bridge status.
-- Sent periodically when a player is hosting and has active links. Lets other
--  players know that they can route messages through them to any destinations
--  listed.
function Proto.handlers.BROADCAST.ST( job, sender )
	if not job.complete then return end

	-- Ignore this from ourself.
	if sender == Me.fullname then return end

	-- Parse message.
	local version, request, secure_hash1, secure_hash2, bands =
	                   strmatch( job.text, "^ST (%S+) (%S) (%S+) (%S+) (%S+)" )
	if not version then return end

	SaveVersion( version, sender )

	UpdateNodeSecureData( sender, secure_hash1, secure_hash2 )

	-- Bands is either colon separated list or "-" for "none".
	if bands == "-" then
		RemoveBridge( sender )
	else
		-- Add or update the bridge.
		UpdateBridge( sender, bands )
	end

	if request == "?" then
		DebugLog( "Status request from %s.", sender )
		-- "FAST" isn't /really/ necessary, but I think it adds a bit of
		--  urgency to players logging in, especially players who are
		--  relogging, to help them get into a good state ASAP so they can
		--  use RP chat and such.
		BroadcastStatus( sender, "FAST" )
	end

	-- ST is also a response from a player when they can't route our data.
	--  That's sent in a whisper, but we check both types of messages anyway,
	--  since it might be useful anyway.
	CheckSenderRoutes( sender )
end

-- Map ST to WHISPER as well.
Proto.handlers.WHISPER.ST = Proto.handlers.BROADCAST.ST

-------------------------------------------------------------------------------
-- A1: First ACK routing checkpoint.
-- After sending R3 (or receiving R2 that's pointed at ourself) we send an A1
--  (or A2 if A1 targets ourself), which turns into A2 over Bnet, and then A3
--  at the final endpoint. ACK is just like a routed message but it's stripped
--                 of any actual message or source, and just carries the UMID.
function Proto.handlers.WHISPER.A1( job, sender )
	if not IsHosting( true ) then
		-- Likely a logical error.
		DebugLog( "Ignored A1 message because we aren't hosting." )
		return
	end
	local umid, dest = strmatch( job.text, "^A1 (%S+) ([^%d%s]*%d+[AH])" )

	if not dest then
		return false
	end

	local secure = job.prefix ~= ""
	if secure then
		if m_secure_channel ~= job.prefix then
			-- Not listening to this secure channel. Let the sender know that
			--  we can't handle this request by updating them with our status.
			DebugLog( "Couldn't send A1 message because of secure mismatch." )
			BroadcastStatus( sender )
			return false
		end
	end

	local link = SelectLink( dest, secure )
	if not link then
		-- todo: respond to requester.
		-- Don't have any links to that destination, let the sender know by
		--  updating them with our status.
		BroadcastStatus( sender )
		return false
	end

	-- We always use "FAST" priority for A* messages. If they end up getting
	--  stuck in network congestion, that just causes /more/ congestion because
	--               then the original sender will be resending their messages.
	SendBnetMessage( link, { "A2", umid, dest }, secure, "FAST" )
end

-------------------------------------------------------------------------------
-- A2: Second ACK routing checkpoint.
-- The second step to routing, crossing the band divide over a Bnet link.
function Proto.handlers.BNET.A2( job, sender )
	if not IsHosting( true ) then
		-- Likely a logical error.
		DebugLog( "Ignored A2 message because we aren't hosting." )
		return
	end
	local umid, dest = job.text:match( "^A2 (%S+) ([^%d%s]*%d+[AH])" )
	if not dest then return end

	if dest:lower() == m_my_dest:lower() then
		-- This message is for us, so we can skip the A3.
		OnAckReceived( umid )
	else
		local send_to = DestToFullname( dest )
		if not send_to then return end
		-- Note that we can still broadcast to any secure channel, even if
		--  we aren't listening to it, so we copy the job prefix directly.
		local job = Comm.SendAddonPacket( send_to, true,
		                                "A3 " .. umid, job.prefix, "FAST" )
	end
end

---------------------------------------------------------------------------
-- A3: Final ACK routing checkpoint. Anything received through here is a
--  message for us.
function Proto.handlers.WHISPER.A3( job, sender )
	local umid = job.text:match( "^A3 (%S+)" )
	if not umid then return end
	OnAckReceived( umid )
end

-------------------------------------------------------------------------------
-- R0 is a basic wrapper for local addon messages. Basically it's the same as
--  R3 except the source is always `sender`, and there isn't any other metadata
--  like a UMID.
function Proto.handlers.WHISPER.R0( job, sender )
	-- R0 <message>
	local message = job.text:sub(4)
	local source = DestFromFullname( sender, Me.faction )
	OnMessageReceived( source, nil, message, job )
end

Proto.handlers.BROADCAST.R0 = Proto.handlers.WHISPER.R0

-------------------------------------------------------------------------------
-- R1: First message routing checkpoint. This is when a player selects us as a
--  bridge and passes data to us to be routed to a foreign destination that we
--  have access to.
function Proto.handlers.WHISPER.R1( job, sender )
	if not IsHosting( true ) then
		-- Likely a logical error.
		DebugLog( "Ignored R1 message because we aren't hosting." )
		return
	end

	-- One key feature we have designed in the Comm interface is the ability to
	--  pass data to jobs progressively, meaning that we don't need the entire
	--  data for a message before we can start forwarding it. That way, if we
	--  have a huge job of transferring 10000 bytes (someone's big ass
	--  profile), each checkpoint won't be waiting several seconds for the
	--  entire message to transfer, like a pipeline operation. In the grander
	--  scheme of things, bandwidth is also shared between other messages in
	--  progress, so one buttload of data isn't going to clog us until it's
	--  done.
	--
	-- Here's a picture of what it looks like. Data to be transfered is "ABCD"
	--  (four chunks). The left method buffers everything and gets much much
	--  longer if there is a lot of data to transfer, i.e. something like
	--  CHUNKS * 3 instead of CHUNKS + 3 time.
	--
	--   Without the pipelining.        | With the pipelining.
	--   SOURCE----R1------R2------R3   | SOURCE----R1------R2------R3
	-- T  BCD   -> A                    |  BCD   -> A
	-- I   CD   -> AB                   |   CD   ->  B   -> A
	-- M    D   -> ABC                  |    D   ->   C  ->  B   -> A
	-- E        ->  BCD -> A            |        ->    D ->   C  -> AB
	--               CD -> AB           |                ->    D -> ABC
	--                D -> ABC          |                        -> ABCD (DONE)
	--                  ->  BCD -> A
	--                       CD -> AB
	--                        D -> ABC
	--                          -> ABCD (DONE)
	if not job.forwarder then
		-- This is a new job, so our task here is basically to parse the
		--  R1 header, create a forwarding job, and then forward this chunk.
		--  If it's the only chunk, then our routing for this message is
		--  completed right here.
		local umid, flags, destination, message_data =
		         strmatch( job.text, "^R1 (%S+) (%S+) ([^%d%s]*%d+[AH]) (.+)" )
		if not destination then
			DebugLog( "Bad R1 message." )

			-- Returning `false` from a Comm job handler will prevent any
			--  further callbacks from being triggered for that job (basically
			--  pipes any further message data received into the trash).
			return false
		end

		-- If the job is using a custom prefix, then this is a "secure"
		-- message.
		local prefix = job.prefix
		local secure = prefix ~= ""
		if secure then
			if m_secure_channel ~= prefix then
				-- Can't forward secure channels that we aren't currently on.
				DebugLog( "Couldn't send R1 message - secure mismatch." )
				BroadcastStatus( sender )
				return false
			end
		end

		local link = SelectLink( destination, secure )
		if not link then
			-- We can't reach the destination requested. No link. Send the
			--  requester our status so they don't try this again.
			BroadcastStatus( sender )
			return false
		end

		local forwarder = Comm.SendBnetPacket( link )
		job.forwarder = forwarder
		forwarder:SetPrefix( prefix ) -- Copy the prefix used.

		-- For secure messages, we use a higher priority. Basically, we don't
		--  really route any sort of "extra" traffic on secure channels. All of
		--  the secure traffic should be directly relevant to us (our linked
		--  group).
		forwarder:SetPriority( secure and "FAST" or "LOW" )

		local source = DestFromFullname( sender, Me.faction )
		forwarder:AddText( job.complete, ("R2 %s %s %s %s %s"):format(
		                      umid, flags, source, destination, message_data ))

		-- New data received is appended, so we clear it here to make it fresh
		--  for the next chunk received.
		job.text = ""
	else
		-- For any additional chunks received, we pass them right to our
		--  forwarder job to the next node. Easy! `job.complete` will tie up
		--  the end.
		job.forwarder:AddText( job.complete, job.text )
		job.text = ""
	end
end

-------------------------------------------------------------------------------
-- Send an ACK message back to the `dest` specified, carrying their `umid` back
--  to them, so they can confirm that their message was sent successfully.
-- This is called from R2, either directly inside if we are the R3 target as
--  well, or in a callback for after we put the R3 message out on the line.
-- In other words, there's a bit of importance of the order, if we send it
--  after we're done putting R3 out on the line, then the ACK will most
--                                certainly fail if we fail to transmit the R3.
local function SendAck( dest, umid )
	DebugLog2( "Sending ACK", dest, umid )
	local sender = {
		ack   = true;
		umids = { [umid] = { umid = umid, dest = dest, tries = 0} };
		msg   = "";
	}

	m_senders[sender] = sender
	ProcessSender( sender )
end                                                     Proto.SendAck = SendAck

-------------------------------------------------------------------------------
-- The Comm API can call this after it successfully puts our message out on
--  the line (that is, after the WoW send function is called).
local function OnR3Sent( job )
	SendAck( job.ack_dest, job.umid )
end

-------------------------------------------------------------------------------
-- R2: Second message routing checkpoint. This is after the message has crossed
--  a band divide, over Battle.net links.
function Proto.handlers.BNET.R2( job, sender )
	-- `skip_r3_for_self` is a flag (set inside here) that this message is
	--  targeting us, so we don't need to send an R3 (to ourself), and once the
	--                       message is complete we can process it immediately.
	if not job.skip_r3_for_self then
		if not job.forwarder then
			local pattern = "^R2 (%S+) (%S+) ([^%d%s]+%d+[AH]) ([^%d%s]*)(%d+[AH]) (.+)"
			local umid, flags, source, dest_name, dest_band, message_data =
			                                      strmatch( job.text, pattern )
			if not dest_name then return false end

			local destination = dest_name .. dest_band

			if destination:lower() == m_my_dest:lower() then
				-- We are the destination, so we can skip creating another
				--  forwarder. Once this message is complete, we proces it for
				--  ourself.
				job.skip_r3_for_self = true
			else
				-- Don't forward if we aren't hosting.
				if not IsHosting( true ) then
					-- Likely a logical error, as nobody should be picking us
					--  for a link if we aren't hosting.
					DebugLog( "Ignored R2 message because we aren't hosting." )
					return
				end

				-- The dest can either be a full destination, or just a band
				--  name. In the former case, the R3 is a whispered addon
				--  message to that player. In the latter case, dest is ignored
				--  and we forward the message as an R3 to our local broadcast
				--  channel.
				local send_to
				if dest_name ~= "" then
					send_to = DestToFullname( destination )
				else
					send_to = "*"
				end

				local forwarder = Comm.SendAddonPacket( send_to )
				job.forwarder = forwarder
				if flags:find("G") then
					-- The "G" flag dictates that this is a "guaranteed"
					--  message. In that case, we setup a callback to be
					--  triggered after the R3 message is put out on the line.
					--  The Comm API will call it after sending the last chunk.
					forwarder:SetSentCallback( OnR3Sent )

					-- Userdata for the callback, arguments for SendAck.
					forwarder.umid     = umid
					forwarder.ack_dest = source
				end

				-- Forward text.
				forwarder:SetPrefix( job.prefix )
				forwarder:SetPriority( job.prefix ~= "" and "FAST" or "LOW" )
				forwarder:AddText( job.complete,
				          ("R3 %s %s %s"):format( umid, source, message_data ))
				job.text = ""
			end
		else
			-- Forward text.
			job.forwarder:AddText( job.complete, job.text )
			job.text = ""
		end
	end

	if job.skip_r3_for_self then
		-- This is for when we are the final endpoint already, so we skip the
		--  R3 message and go straight to processing.
		local pattern = "^R2 (%S+) (%S+) ([^%d%s]+%d+[AH]) [^%d%s]*%d+[AH] (.+)"
		local umid, flags, source, message_data = strmatch( job.text, pattern )

		if flags:find("G") and job.complete then
			-- Send an ack for guaranteed messages, but only after we receive
			--  the entire message.
			SendAck( source, umid )
		end

		-- Pass to message handler.
		OnMessageReceived( source, umid, message_data, job )
	end
end

-------------------------------------------------------------------------------
-- R3: Final routing checkpoint. This is a message for us.
function Proto.handlers.WHISPER.R3( job, sender )

	-- R3 contains the source of the message, the umid, and the message
	--  contents.
	local pattern = "^R3 (.+) ([^%d%s]+%d+[AH]) (.+)"
	local umid, source, message = strmatch( job.text, pattern )
	if not source then return false end

	OnMessageReceived( source, umid, message, job )
end

-- Map R3 to BROADCAST as well.
Proto.handlers.BROADCAST.R3 = Proto.handlers.WHISPER.R3

-------------------------------------------------------------------------------
-- EVENTS
-------------------------------------------------------------------------------
-- BN_FRIEND_INFO_CHANGED, triggered when Battle.net friend data (or similar)
--  stuff changes.
function Proto.OnBnFriendInfoChanged()
	if not Proto.startup_complete then return end
	-- When we see this event, a player may have gone offline, which means a
	--  link may have gone offline, and we want to purge them. This event is
	--  also spammed to death at times, so we merge duplicate events into a
	--  single call on the next frame (and maybe the next frame will be a safer
	--  spot to scan the Battle.net friends anyway to catch the offline
	--  status).
	Me.Timer_Start( "purge_offline", "ignore", 0.01, PurgeOfflineLinks, true )
end

-------------------------------------------------------------------------------
-- UPDATE_MOUSEOVER_UNIT, triggered whenever the player mouses over a unit.
--  Note that this doesn't necessarily mean mousing over a player - could be
--  an NPC.
function Proto.OnMouseoverUnit()
	-- Basically we want to keep track of any foreign bands that we touch,
	--  treating them as "active" for a while, until activity with them ceases.
	TouchUnitBand( "mouseover" )
end

-------------------------------------------------------------------------------
-- PLAYER_TARGET_CHANGED, triggered whenever the player changes their target.
function Proto.OnTargetUnit()
	TouchUnitBand( "target" )
end

-------------------------------------------------------------------------------
-- Phase three of startup code, called after we have waited for status replies.
local function Start3()
	DebugLog2( "PROTO STARTUP 3" )
	Proto.init_state = 3
	Proto.startup_complete = true
	Me:SendMessage( "CROSSRP_PROTO_START3" )

	-- Start our update cycle. This starts a periodic timer too.
	Update()

	-- Every so often we want to clean up our UMID table. Might even be a good
	--  idea to leave it dirty, as it'd be minimal memory leaked.
	Me.Timer_Start( "proto_clean_umids", "push", 35.0, Proto.CleanSeenUMIDs )

	Start3 = nil
end

-------------------------------------------------------------------------------
-- Phase two of startup code, called after a wait period after sending out Bnet
--  probes.
local function Start2()
	DebugLog2( "PROTO STARTUP 2" )
	Proto.init_state = 2

	-- Register the rest of our handlers.
	for dist, set in pairs( Proto.handlers ) do
		for command, handler in pairs( set ) do
			Comm.SetMessageHandler( dist, command, handler )
		end
	end
	Proto.handlers = nil

	-- Don't start hosting if the player has high latency (note that this might
	--  be unacceptable for regions/realms that have typically high latency?).
	if not HasUnsuitableLag() then
		StartHosting()
	end

	Me:SendMessage( "CROSSRP_PROTO_START2" )

	-- This status broadcast will request the status from other players.
	m_status_broadcast_time = GetTime()
	BroadcastStatus( nil, "FAST", true )
	if m_hosting then
		-- We already sent our Bnet status, and unless we're hosting, the
		--  status was just to let people know that we have Cross RP and to
		--  get their status, not to tell them that we're hosting.
		-- If we are hosting, then this second Bnet status message will contain
		--  proper load data and let other links know that we're starting up
		--  our hosting.
		BroadcastBnetStatus( false, false )
	end

	-- And we wait 3 seconds for status responses before doing the final
	--  initialization.
	Me.Timer_Start( "proto_startup3", "ignore", 3.0, Start3 )

	Start2 = nil
end


-------------------------------------------------------------------------------
-- Phase one of startup code, called one second after Init.
local function Start1()
	DebugLog2( "PROTO STARTUP 1" )
	Proto.init_state = 1
	Proto.start_time = GetTime()
	-- (This used to be when we used the crossrp channel filter as a flag to
	--  enable RP chat display.)
--	if not Me.db.char.proto_crossrp_channel_added then
--		Me.db.char.proto_crossrp_channel_added = true
--		ChatFrame_AddChannel( DEFAULT_CHAT_FRAME, Me.data_channel )
--	end

	-- This is the "public" prefix that we use. When in secure mode, we also
	--  send messages on private channels, which is
	--  `m_secure_channel .. "+RP"`.
	C_ChatInfo.RegisterAddonMessagePrefix( "+RP" )

	-- Just registering one of our comm message handlers for now, for receiving
	--  replies from people we probe. We don't want to receive other message
	--  types right now, since we're not in a good state to yet.
	Comm.SetMessageHandler( "BNET", "HI", Proto.handlers.BNET.HI )

	-- Sending this message before we do the broadcast status, as the message
	--  callbacks might adjust our settings, and in turn adjust what we send
	--  in the probes.
	Me:SendMessage( "CROSSRP_PROTO_START" )

	BroadcastBnetStatus( true, true, nil, "FAST" )

	-- Sometimes Bnet messages seem quite delayed, so using 3 seconds as a
	--  wait time. It's around 500ms with minimum latency for a there-and-back
	--  message, and that's 2500ms extra.
	Me.Timer_Start( "proto_startup2", "ignore", 3, Start2 )
	Start1 = nil
end

-------------------------------------------------------------------------------
-- This is the second stage of the initial startup, waiting for the game to
--  initialize the channel system.
local function WaitForGameChannels( retries )
	retries = retries or 5
	if retries > 0 then
		-- Basically we wait until some channels are available before trying to
		--  join our broadcast channel. That way the user never sees crossrp
		--  as channel 1
		local has_channels = false
		DebugLog2( "Checking game channels..." )
		for i = 1, 10 do
			DebugLog2( i, GetChannelName(i) )
			if GetChannelName(i) ~= 0 then
				has_channels = true

			end
		end

		if not has_channels then
			DebugLog( "Delaying broadcast join. Not available yet." )
			Me.Timer_Start( "proto_waiting_for_channels", "push",
				                          1.0, WaitForGameChannels, retries-1 )
			return
		end
	end

	-- The above can only find a partial channel list, and likely the only
	--  way this check will pass here is during a /reload and not during login.
	if GameChannelExists( Me.data_channel ) then
		return Start1()
	end

	-- The channel joining system is really, really annoying, so we're gonna
	--  just add a huge and obnoxious delay here (happens when the user first
	--  logs in). If the bug still persists, we can just make it a permanent
	--  channel. That way, if the bug happens, then people can just move the
	--                channel manually, and it will never happen to them again.
	Me.Timer_Start( "proto_waiting_for_channels", "push", 10.0, function()
		JoinGameChannel( Me.data_channel, Start1 )
	end)
end

-------------------------------------------------------------------------------
-- Start up the protocol service. Entry point.
--
local function Init()

	-- Generating a UMID prefix. This is combined with an incrementing number
	--  to make UMIDs. They're used to filter duplicate messages when doing
	--                                      extra sends for message guarantees.
	local prefix_digits =
	           "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
	local umid_prefix = ""
	for i = 1, 5 do
		local digit = math.random( 1, #prefix_digits )
		umid_prefix = umid_prefix .. prefix_digits:sub( digit, digit )
	end
	m_umid_prefix = umid_prefix

	-- Cache our destination.
	m_my_dest = DestFromFullname( Me.fullname, Me.faction )
	m_my_band = GetBandFromDest( m_my_dest )

	-- Cache realms linked to ours. GetAutoCompleteRealms returns a table of
	--  realms that are connected to us.
	m_linked_realms[Me.realm] = true
	for k, v in pairs( GetAutoCompleteRealms() ) do
		m_linked_realms[v] = true
	end

	-- We have a small delay here, as the channel system is usually fairly
	--  funky right whne you log in.
	Proto.init_state = 0
	Me.Timer_Start( "proto_start", "push", START_DELAY, function()
		WaitForGameChannels()
	end)

	-- Clean up memory.
	Proto.Init = nil
	Init = nil
end                                                           Proto.Init = Init


-------------------------------------------------------------------------------
-- DIAGNOSTICS
-------------------------------------------------------------------------------
-- Dump bridge node set.
function Proto.DebugPrintBridges()
	for band, set in pairs( m_bridges ) do
		Me.Print( "[%s] : nodes=%d load=%s quota=%d", band,
		           set.node_counts.all, set.load_sums.all, set.quota_sums.all )
		for name, data in pairs( set.nodes ) do
			local time = GetTime() - data.time
			Me.Print( "  %s: load=%d secure=%d time=%d", name, data.load,
			             data.subset == "secure" and "YES" or "NO", time )
		end
	end
end

-------------------------------------------------------------------------------
-- Dump link node set.
function Proto.DebugPrintLinks()
	for band, set in pairs( m_links ) do
		Me.Print( "[%s] : nodes=%d load=%s quota=%d", band,
		           set.node_counts.all, set.load_sums.all, set.quota_sums.all )
		for gameid, data in pairs( set.nodes ) do
			local name = Proto.GetFullnameFromGameID( gameid ) or "<Unknown>"
			local time = GetTime() - data.time
			Me.Print( "  %s (%d): load=%d secure=%s time=%d", name, gameid,
			       data.load, data.subset == "secure" and "YES" or "NO", time )
		end
	end
end

-------------------------------------------------------------------------------
-- Print statistics of versions that people are using (that we saw through ST
--  or HI). Data source is m_user_versions and m_version_counts.
function Proto.DebugPrintVersions()
	local ordered = {}
	local total_count = 0
	for k, v in pairs( m_version_counts ) do
		local version_code = Me.GetVersionCode( k ) or 0
		total_count = total_count + v

		table.insert( ordered, {
			version = k;
			version_code = version_code;
			count = v;
		})
	end

	table.sort( ordered, function( a, b )
		return a.version_code > b.version_code
	end)

	if not next( ordered ) then
		Me.Print( "No version data yet." )
		return
	end

	Me.Print( "Cross RP versions you've seen:" )
	for k, v in ipairs( ordered ) do
		local percent = v.count * 100 / total_count
		Me.Print( "  %s: %d users (%d%%)", v.version, v.count, percent )
	end
end
